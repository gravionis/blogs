<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/content/posts/system_design/core_design_patterns.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/content/posts/system_design/core_design_patterns.md" />
              <option name="originalContent" value="+++&#10;date = '2024-05-03T12:44:47+10:00'&#10;draft = false&#10;title = '23 Core Design Patterns'&#10;tags = ['Core Design Patterns', 'Interview']&#10;+++&#10;&#10;About Core Design Patterns.&#10;&#10;## Table of Contents&#10;&#10;- [Creational Patterns](#creational-patterns)&#10;  - [Singleton](#singleton)&#10;  - [Factory Method](#factory-method)&#10;  - [Abstract Factory](#abstract-factory)&#10;  - [Builder](#builder)&#10;  - [Prototype](#prototype)&#10;- [Structural Patterns](#structural-patterns)&#10;  - [Adapter](#adapter)&#10;  - [Bridge](#bridge)&#10;  - [Composite](#composite)&#10;  - [Decorator](#decorator)&#10;  - [Facade](#facade)&#10;  - [Flyweight](#flyweight)&#10;  - [Proxy](#proxy)&#10;- [Behavioral Patterns](#behavioral-patterns)&#10;  - [Chain of Responsibility](#chain-of-responsibility)&#10;  - [Command](#command)&#10;  - [Interpreter](#interpreter)&#10;  - [Iterator](#iterator)&#10;  - [Mediator](#mediator)&#10;  - [Memento](#memento)&#10;  - [Observer](#observer)&#10;  - [State](#state)&#10;  - [Strategy](#strategy)&#10;  - [Template Method](#template-method)&#10;  - [Visitor](#visitor)&#10;- [Summary](#summary)&#10;&#10;---&#10;&#10;## Creational Patterns&#10;&#10;### Singleton&#10;&#10;Ensures a class has only one instance and provides a global point of access to it.&#10;&#10;**Example (Java):**&#10;```java&#10;public class Singleton {&#10;    private static Singleton uniqueInstance;&#10;    private Singleton() {}&#10;    public static synchronized Singleton getInstance() {&#10;        if (uniqueInstance == null) {&#10;            uniqueInstance = new Singleton();&#10;        }&#10;        return uniqueInstance;&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need a single shared resource (e.g., config, logger, cache).&#10;&#10;**When not to use:**  &#10;&#10;- When you need multiple instances (e.g., for testing, parallelism).&#10;- Can introduce hidden dependencies and global state.&#10;&#10;---&#10;&#10;### Factory Method&#10;&#10;Defines an interface for creating an object, but lets subclasses decide which class to instantiate.&#10;&#10;**Example (Java):**&#10;```java&#10;public abstract class Animal {&#10;    public abstract String speak();&#10;}&#10;&#10;public class Dog extends Animal {&#10;    public String speak() { return &quot;Woof!&quot;; }&#10;}&#10;&#10;public class Cat extends Animal {&#10;    public String speak() { return &quot;Meow!&quot;; }&#10;}&#10;&#10;public abstract class AnimalFactory {&#10;    public abstract Animal createAnimal();&#10;}&#10;&#10;public class DogFactory extends AnimalFactory {&#10;    public Animal createAnimal() { return new Dog(); }&#10;}&#10;&#10;public class CatFactory extends AnimalFactory {&#10;    public Animal createAnimal() { return new Cat(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When a class can't anticipate the type of objects it needs to create.&#10;&#10;**When not to use:**  &#10;&#10;- When object creation is simple and doesn't need abstraction.&#10;&#10;---&#10;&#10;### Abstract Factory&#10;&#10;Provides an interface for creating families of related or dependent objects without specifying their concrete classes.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Button {&#10;    void paint();&#10;}&#10;&#10;public class WinButton implements Button {&#10;    public void paint() { System.out.println(&quot;Windows Button&quot;); }&#10;}&#10;&#10;public class MacButton implements Button {&#10;    public void paint() { System.out.println(&quot;Mac Button&quot;); }&#10;}&#10;&#10;public interface GUIFactory {&#10;    Button createButton();&#10;}&#10;&#10;public class WinFactory implements GUIFactory {&#10;    public Button createButton() { return new WinButton(); }&#10;}&#10;&#10;public class MacFactory implements GUIFactory {&#10;    public Button createButton() { return new MacButton(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to create families of related objects.&#10;&#10;**When not to use:**  &#10;&#10;- When products don't need to be related.&#10;&#10;---&#10;&#10;### Builder&#10;&#10;Separates the construction of a complex object from its representation.&#10;&#10;**Example (Java):**&#10;```java&#10;public class Burger {&#10;    private boolean cheese;&#10;    private boolean lettuce;&#10;&#10;    public static class Builder {&#10;        private boolean cheese;&#10;        private boolean lettuce;&#10;&#10;        public Builder addCheese() {&#10;            cheese = true;&#10;            return this;&#10;        }&#10;        public Builder addLettuce() {&#10;            lettuce = true;&#10;            return this;&#10;        }&#10;        public Burger build() {&#10;            Burger burger = new Burger();&#10;            burger.cheese = this.cheese;&#10;            burger.lettuce = this.lettuce;&#10;            return burger;&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When constructing complex objects step by step.&#10;&#10;**When not to use:**  &#10;&#10;- For simple objects with few parameters.&#10;&#10;---&#10;&#10;### Prototype&#10;&#10;Creates new objects by copying an existing object.&#10;&#10;**Example (Java):**&#10;```java&#10;public abstract class Prototype implements Cloneable {&#10;    public Prototype clone() {&#10;        try {&#10;            return (Prototype) super.clone();&#10;        } catch (CloneNotSupportedException e) {&#10;            throw new AssertionError();&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When object creation is costly and similar objects are needed.&#10;&#10;**When not to use:**  &#10;&#10;- When objects are simple or copying is not needed.&#10;&#10;---&#10;&#10;## Structural Patterns&#10;&#10;### Adapter&#10;&#10;Allows incompatible interfaces to work together.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface USASocket {&#10;    int voltage();&#10;}&#10;&#10;public class EuropeanSocket {&#10;    public int voltage() { return 230; }&#10;}&#10;&#10;public class SocketAdapter implements USASocket {&#10;    private EuropeanSocket europeanSocket;&#10;    public SocketAdapter(EuropeanSocket socket) {&#10;        this.europeanSocket = socket;&#10;    }&#10;    public int voltage() {&#10;        return europeanSocket.voltage();&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When integrating with legacy or third-party code.&#10;&#10;**When not to use:**  &#10;&#10;- When you can refactor code directly.&#10;&#10;---&#10;&#10;### Bridge&#10;&#10;Separates abstraction from implementation.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface DrawingAPI {&#10;    void drawCircle(int x, int y, int r);&#10;}&#10;&#10;public class DrawingAPI1 implements DrawingAPI {&#10;    public void drawCircle(int x, int y, int r) {&#10;        System.out.println(&quot;API1: Circle at &quot; + x + &quot;,&quot; + y + &quot; radius &quot; + r);&#10;    }&#10;}&#10;&#10;public abstract class Shape {&#10;    protected DrawingAPI api;&#10;    public Shape(DrawingAPI api) { this.api = api; }&#10;    public abstract void draw();&#10;}&#10;&#10;public class Circle extends Shape {&#10;    private int x, y, r;&#10;    public Circle(int x, int y, int r, DrawingAPI api) {&#10;        super(api);&#10;        this.x = x; this.y = y; this.r = r;&#10;    }&#10;    public void draw() { api.drawCircle(x, y, r); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When abstraction and implementation should vary independently.&#10;&#10;**When not to use:**  &#10;&#10;- When only one implementation is needed.&#10;&#10;---&#10;&#10;### Composite&#10;&#10;Composes objects into tree structures.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Component {&#10;    void operation();&#10;}&#10;&#10;public class Leaf implements Component {&#10;    public void operation() { System.out.println(&quot;Leaf&quot;); }&#10;}&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class Composite implements Component {&#10;    private List&lt;Component&gt; children = new ArrayList&lt;&gt;();&#10;    public void add(Component component) { children.add(component); }&#10;    public void operation() {&#10;        for (Component child : children) {&#10;            child.operation();&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to treat individual and composite objects uniformly.&#10;&#10;**When not to use:**  &#10;&#10;- When hierarchy is not needed.&#10;&#10;---&#10;&#10;### Decorator&#10;&#10;Adds new functionality to an object dynamically.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Coffee {&#10;    int cost();&#10;}&#10;&#10;public class SimpleCoffee implements Coffee {&#10;    public int cost() { return 5; }&#10;}&#10;&#10;public class MilkDecorator implements Coffee {&#10;    private Coffee coffee;&#10;    public MilkDecorator(Coffee coffee) { this.coffee = coffee; }&#10;    public int cost() { return coffee.cost() + 2; }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to add responsibilities to objects dynamically.&#10;&#10;**When not to use:**  &#10;&#10;- When subclassing is simpler.&#10;&#10;---&#10;&#10;### Facade&#10;&#10;Provides a simplified interface to a complex subsystem.&#10;&#10;**Example (Java):**&#10;```java&#10;public class CPU { public void freeze() {} }&#10;public class Memory { public void load(int pos, String data) {} }&#10;&#10;public class ComputerFacade {&#10;    private CPU cpu;&#10;    private Memory memory;&#10;    public ComputerFacade() {&#10;        cpu = new CPU();&#10;        memory = new Memory();&#10;    }&#10;    public void start() {&#10;        cpu.freeze();&#10;        memory.load(0, &quot;data&quot;);&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you want to provide a simple interface to a complex system.&#10;&#10;**When not to use:**  &#10;&#10;- When subsystem is already simple.&#10;&#10;---&#10;&#10;### Flyweight&#10;&#10;Reduces memory usage by sharing data.&#10;&#10;**Example (Java):**&#10;```java&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class Flyweight {&#10;    private String shared;&#10;    public Flyweight(String shared) { this.shared = shared; }&#10;}&#10;&#10;public class FlyweightFactory {&#10;    private Map&lt;String, Flyweight&gt; flyweights = new HashMap&lt;&gt;();&#10;    public Flyweight getFlyweight(String shared) {&#10;        if (!flyweights.containsKey(shared)) {&#10;            flyweights.put(shared, new Flyweight(shared));&#10;        }&#10;        return flyweights.get(shared);&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When many objects share common data.&#10;&#10;**When not to use:**  &#10;&#10;- When objects are unique.&#10;&#10;---&#10;&#10;### Proxy&#10;&#10;Provides a surrogate for another object.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Subject {&#10;    void request();&#10;}&#10;&#10;public class RealSubject implements Subject {&#10;    public void request() { System.out.println(&quot;RealSubject&quot;); }&#10;}&#10;&#10;public class Proxy implements Subject {&#10;    private RealSubject real;&#10;    public Proxy(RealSubject real) { this.real = real; }&#10;    public void request() {&#10;        System.out.println(&quot;Proxy: Checking access&quot;);&#10;        real.request();&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For access control, lazy loading, logging.&#10;&#10;**When not to use:**  &#10;&#10;- When direct access is acceptable.&#10;&#10;---&#10;&#10;## Behavioral Patterns&#10;&#10;### Chain of Responsibility&#10;&#10;Passes a request along a chain of handlers.&#10;&#10;**Example (Java):**&#10;```java&#10;public abstract class Handler {&#10;    protected Handler next;&#10;    public void setNext(Handler next) { this.next = next; }&#10;    public void handle(String request) {&#10;        if (next != null) next.handle(request);&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When multiple objects can handle a request.&#10;&#10;**When not to use:**  &#10;&#10;- When only one handler is needed.&#10;&#10;---&#10;&#10;### Command&#10;&#10;Encapsulates a request as an object.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Command {&#10;    void execute();&#10;}&#10;&#10;public class LightOnCommand implements Command {&#10;    public void execute() { System.out.println(&quot;Light On&quot;); }&#10;}&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class Remote {&#10;    private List&lt;Command&gt; commands = new ArrayList&lt;&gt;();&#10;    public void addCommand(Command cmd) { commands.add(cmd); }&#10;    public void run() {&#10;        for (Command cmd : commands) { cmd.execute(); }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For undo/redo, queuing, logging.&#10;&#10;**When not to use:**  &#10;&#10;- When simple method calls suffice.&#10;&#10;---&#10;&#10;### Interpreter&#10;&#10;Defines a grammar and provides an interpreter.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Expression {&#10;    int interpret();&#10;}&#10;&#10;public class Number implements Expression {&#10;    private int value;&#10;    public Number(int value) { this.value = value; }&#10;    public int interpret() { return value; }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For languages, expressions, parsing.&#10;&#10;**When not to use:**  &#10;&#10;- For simple or infrequent grammar.&#10;&#10;---&#10;&#10;### Iterator&#10;&#10;Provides a way to access elements sequentially.&#10;&#10;**Example (Java):**&#10;```java&#10;import java.util.Iterator;&#10;import java.util.List;&#10;&#10;public class MyIterator implements Iterator&lt;String&gt; {&#10;    private List&lt;String&gt; collection;&#10;    private int index = 0;&#10;    public MyIterator(List&lt;String&gt; collection) { this.collection = collection; }&#10;    public boolean hasNext() { return index &lt; collection.size(); }&#10;    public String next() { return collection.get(index++); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to traverse a collection.&#10;&#10;**When not to use:**  &#10;&#10;- When direct access is sufficient.&#10;&#10;---&#10;&#10;### Mediator&#10;&#10;Encapsulates how objects interact.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Mediator {&#10;    void notify(Component sender, String event);&#10;}&#10;&#10;public class Component {&#10;    private Mediator mediator;&#10;    public Component(Mediator mediator) { this.mediator = mediator; }&#10;    public void doSomething() { mediator.notify(this, &quot;event&quot;); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When objects communicate in complex ways.&#10;&#10;**When not to use:**  &#10;&#10;- When communication is simple.&#10;&#10;---&#10;&#10;### Memento&#10;&#10;Captures and restores an object's state.&#10;&#10;**Example (Java):**&#10;```java&#10;public class Memento {&#10;    private String state;&#10;    public Memento(String state) { this.state = state; }&#10;    public String getState() { return state; }&#10;}&#10;&#10;public class Originator {&#10;    private String state;&#10;    public void setState(String state) { this.state = state; }&#10;    public Memento save() { return new Memento(state); }&#10;    public void restore(Memento memento) { state = memento.getState(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For undo/redo functionality.&#10;&#10;**When not to use:**  &#10;&#10;- When state is simple or not needed.&#10;&#10;---&#10;&#10;### Observer&#10;&#10;One-to-many dependency so dependents are notified of changes.&#10;&#10;**Example (Java):**&#10;```java&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public interface Observer {&#10;    void update();&#10;}&#10;&#10;public class Subject {&#10;    private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();&#10;    public void attach(Observer obs) { observers.add(obs); }&#10;    public void notifyObservers() {&#10;        for (Observer obs : observers) { obs.update(); }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For event handling, UI updates.&#10;&#10;**When not to use:**  &#10;&#10;- When only one object needs notification.&#10;&#10;---&#10;&#10;### State&#10;&#10;Alters behavior when internal state changes.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface State {&#10;    void handle();&#10;}&#10;&#10;public class Context {&#10;    private State state;&#10;    public Context(State state) { this.state = state; }&#10;    public void request() { state.handle(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When object behavior depends on state.&#10;&#10;**When not to use:**  &#10;&#10;- When state changes are rare.&#10;&#10;---&#10;&#10;### Strategy&#10;&#10;Encapsulates interchangeable algorithms.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Strategy {&#10;    int execute(int[] data);&#10;}&#10;&#10;public class SortStrategy implements Strategy {&#10;    public int execute(int[] data) {&#10;        java.util.Arrays.sort(data);&#10;        return data[0]; // Just for demonstration&#10;    }&#10;}&#10;&#10;public class Context {&#10;    private Strategy strategy;&#10;    public Context(Strategy strategy) { this.strategy = strategy; }&#10;    public int doTask(int[] data) { return strategy.execute(data); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When multiple algorithms are needed.&#10;&#10;**When not to use:**  &#10;&#10;- When only one algorithm is used.&#10;&#10;---&#10;&#10;### Template Method&#10;&#10;Defines the skeleton of an algorithm, deferring steps to subclasses.&#10;&#10;**Example (Java):**&#10;```java&#10;public abstract class AbstractClass {&#10;    public final void templateMethod() {&#10;        step1();&#10;        step2();&#10;    }&#10;    protected abstract void step1();&#10;    protected abstract void step2();&#10;}&#10;&#10;public class ConcreteClass extends AbstractClass {&#10;    protected void step1() { System.out.println(&quot;Step 1&quot;); }&#10;    protected void step2() { System.out.println(&quot;Step 2&quot;); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When algorithms have invariant steps.&#10;&#10;**When not to use:**  &#10;&#10;- When steps never change.&#10;&#10;---&#10;&#10;### Visitor&#10;&#10;Represents an operation to be performed on elements of an object structure.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Visitor {&#10;    void visit(Element element);&#10;}&#10;&#10;public interface Element {&#10;    void accept(Visitor visitor);&#10;}&#10;&#10;public class ConcreteElement implements Element {&#10;    public void accept(Visitor visitor) { visitor.visit(this); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to perform operations on object structures.&#10;&#10;**When not to use:**  &#10;&#10;- When object structure rarely changes.&#10;&#10;---&#10;&#10;## Summary&#10;&#10;The 23 core design patterns (Gang of Four) are essential tools for software engineers.  &#10;They provide proven solutions to common problems in software design, improve code maintainability, and are frequently discussed in interviews.  &#10;Understanding these patterns helps you write flexible, scalable, and robust code.&#10;" />
              <option name="updatedContent" value="+++&#10;date = '2025-05-03T12:44:47+10:00'&#10;draft = false&#10;title = '23 Core Design Patterns'&#10;tags = ['Core Design Patterns', 'Interview']&#10;+++&#10;&#10;Core design patterns are proven solutions to common software engineering problems. They help structure code for flexibility, scalability, and maintainability. Mastering these patterns is essential for interviews and for building robust, reusable, and understandable software systems.&#10;&#10;## Table of Contents&#10;&#10;- [Creational Patterns](#creational-patterns)&#10;  - [Singleton](#singleton)&#10;  - [Factory Method](#factory-method)&#10;  - [Abstract Factory](#abstract-factory)&#10;  - [Builder](#builder)&#10;  - [Prototype](#prototype)&#10;- [Structural Patterns](#structural-patterns)&#10;  - [Adapter](#adapter)&#10;  - [Bridge](#bridge)&#10;  - [Composite](#composite)&#10;  - [Decorator](#decorator)&#10;  - [Facade](#facade)&#10;  - [Flyweight](#flyweight)&#10;  - [Proxy](#proxy)&#10;- [Behavioral Patterns](#behavioral-patterns)&#10;  - [Chain of Responsibility](#chain-of-responsibility)&#10;  - [Command](#command)&#10;  - [Interpreter](#interpreter)&#10;  - [Iterator](#iterator)&#10;  - [Mediator](#mediator)&#10;  - [Memento](#memento)&#10;  - [Observer](#observer)&#10;  - [State](#state)&#10;  - [Strategy](#strategy)&#10;  - [Template Method](#template-method)&#10;  - [Visitor](#visitor)&#10;- [Summary](#summary)&#10;&#10;---&#10;&#10;## Creational Patterns&#10;&#10;### Singleton&#10;&#10;Ensures a class has only one instance and provides a global point of access to it.&#10;&#10;**Example (Java):**&#10;```java&#10;public class Singleton {&#10;    private static Singleton uniqueInstance;&#10;    private Singleton() {}&#10;    public static synchronized Singleton getInstance() {&#10;        if (uniqueInstance == null) {&#10;            uniqueInstance = new Singleton();&#10;        }&#10;        return uniqueInstance;&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need a single shared resource (e.g., config, logger, cache).&#10;&#10;**When not to use:**  &#10;&#10;- When you need multiple instances (e.g., for testing, parallelism).&#10;- Can introduce hidden dependencies and global state.&#10;&#10;---&#10;&#10;### Factory Method&#10;&#10;Defines an interface for creating an object, but lets subclasses decide which class to instantiate.&#10;&#10;**Example (Java):**&#10;```java&#10;public abstract class Animal {&#10;    public abstract String speak();&#10;}&#10;&#10;public class Dog extends Animal {&#10;    public String speak() { return &quot;Woof!&quot;; }&#10;}&#10;&#10;public class Cat extends Animal {&#10;    public String speak() { return &quot;Meow!&quot;; }&#10;}&#10;&#10;public abstract class AnimalFactory {&#10;    public abstract Animal createAnimal();&#10;}&#10;&#10;public class DogFactory extends AnimalFactory {&#10;    public Animal createAnimal() { return new Dog(); }&#10;}&#10;&#10;public class CatFactory extends AnimalFactory {&#10;    public Animal createAnimal() { return new Cat(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When a class can't anticipate the type of objects it needs to create.&#10;&#10;**When not to use:**  &#10;&#10;- When object creation is simple and doesn't need abstraction.&#10;&#10;---&#10;&#10;### Abstract Factory&#10;&#10;Provides an interface for creating families of related or dependent objects without specifying their concrete classes.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Button {&#10;    void paint();&#10;}&#10;&#10;public class WinButton implements Button {&#10;    public void paint() { System.out.println(&quot;Windows Button&quot;); }&#10;}&#10;&#10;public class MacButton implements Button {&#10;    public void paint() { System.out.println(&quot;Mac Button&quot;); }&#10;}&#10;&#10;public interface GUIFactory {&#10;    Button createButton();&#10;}&#10;&#10;public class WinFactory implements GUIFactory {&#10;    public Button createButton() { return new WinButton(); }&#10;}&#10;&#10;public class MacFactory implements GUIFactory {&#10;    public Button createButton() { return new MacButton(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to create families of related objects.&#10;&#10;**When not to use:**  &#10;&#10;- When products don't need to be related.&#10;&#10;---&#10;&#10;### Builder&#10;&#10;Separates the construction of a complex object from its representation.&#10;&#10;**Example (Java):**&#10;```java&#10;public class Burger {&#10;    private boolean cheese;&#10;    private boolean lettuce;&#10;&#10;    public static class Builder {&#10;        private boolean cheese;&#10;        private boolean lettuce;&#10;&#10;        public Builder addCheese() {&#10;            cheese = true;&#10;            return this;&#10;        }&#10;        public Builder addLettuce() {&#10;            lettuce = true;&#10;            return this;&#10;        }&#10;        public Burger build() {&#10;            Burger burger = new Burger();&#10;            burger.cheese = this.cheese;&#10;            burger.lettuce = this.lettuce;&#10;            return burger;&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When constructing complex objects step by step.&#10;&#10;**When not to use:**  &#10;&#10;- For simple objects with few parameters.&#10;&#10;---&#10;&#10;### Prototype&#10;&#10;Creates new objects by copying an existing object.&#10;&#10;**Example (Java):**&#10;```java&#10;public abstract class Prototype implements Cloneable {&#10;    public Prototype clone() {&#10;        try {&#10;            return (Prototype) super.clone();&#10;        } catch (CloneNotSupportedException e) {&#10;            throw new AssertionError();&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When object creation is costly and similar objects are needed.&#10;&#10;**When not to use:**  &#10;&#10;- When objects are simple or copying is not needed.&#10;&#10;---&#10;&#10;## Structural Patterns&#10;&#10;### Adapter&#10;&#10;Allows incompatible interfaces to work together.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface USASocket {&#10;    int voltage();&#10;}&#10;&#10;public class EuropeanSocket {&#10;    public int voltage() { return 230; }&#10;}&#10;&#10;public class SocketAdapter implements USASocket {&#10;    private EuropeanSocket europeanSocket;&#10;    public SocketAdapter(EuropeanSocket socket) {&#10;        this.europeanSocket = socket;&#10;    }&#10;    public int voltage() {&#10;        return europeanSocket.voltage();&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When integrating with legacy or third-party code.&#10;&#10;**When not to use:**  &#10;&#10;- When you can refactor code directly.&#10;&#10;---&#10;&#10;### Bridge&#10;&#10;Separates abstraction from implementation.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface DrawingAPI {&#10;    void drawCircle(int x, int y, int r);&#10;}&#10;&#10;public class DrawingAPI1 implements DrawingAPI {&#10;    public void drawCircle(int x, int y, int r) {&#10;        System.out.println(&quot;API1: Circle at &quot; + x + &quot;,&quot; + y + &quot; radius &quot; + r);&#10;    }&#10;}&#10;&#10;public abstract class Shape {&#10;    protected DrawingAPI api;&#10;    public Shape(DrawingAPI api) { this.api = api; }&#10;    public abstract void draw();&#10;}&#10;&#10;public class Circle extends Shape {&#10;    private int x, y, r;&#10;    public Circle(int x, int y, int r, DrawingAPI api) {&#10;        super(api);&#10;        this.x = x; this.y = y; this.r = r;&#10;    }&#10;    public void draw() { api.drawCircle(x, y, r); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When abstraction and implementation should vary independently.&#10;&#10;**When not to use:**  &#10;&#10;- When only one implementation is needed.&#10;&#10;---&#10;&#10;### Composite&#10;&#10;Composes objects into tree structures.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Component {&#10;    void operation();&#10;}&#10;&#10;public class Leaf implements Component {&#10;    public void operation() { System.out.println(&quot;Leaf&quot;); }&#10;}&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class Composite implements Component {&#10;    private List&lt;Component&gt; children = new ArrayList&lt;&gt;();&#10;    public void add(Component component) { children.add(component); }&#10;    public void operation() {&#10;        for (Component child : children) {&#10;            child.operation();&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to treat individual and composite objects uniformly.&#10;&#10;**When not to use:**  &#10;&#10;- When hierarchy is not needed.&#10;&#10;---&#10;&#10;### Decorator&#10;&#10;Adds new functionality to an object dynamically.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Coffee {&#10;    int cost();&#10;}&#10;&#10;public class SimpleCoffee implements Coffee {&#10;    public int cost() { return 5; }&#10;}&#10;&#10;public class MilkDecorator implements Coffee {&#10;    private Coffee coffee;&#10;    public MilkDecorator(Coffee coffee) { this.coffee = coffee; }&#10;    public int cost() { return coffee.cost() + 2; }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to add responsibilities to objects dynamically.&#10;&#10;**When not to use:**  &#10;&#10;- When subclassing is simpler.&#10;&#10;---&#10;&#10;### Facade&#10;&#10;Provides a simplified interface to a complex subsystem.&#10;&#10;**Example (Java):**&#10;```java&#10;public class CPU { public void freeze() {} }&#10;public class Memory { public void load(int pos, String data) {} }&#10;&#10;public class ComputerFacade {&#10;    private CPU cpu;&#10;    private Memory memory;&#10;    public ComputerFacade() {&#10;        cpu = new CPU();&#10;        memory = new Memory();&#10;    }&#10;    public void start() {&#10;        cpu.freeze();&#10;        memory.load(0, &quot;data&quot;);&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you want to provide a simple interface to a complex system.&#10;&#10;**When not to use:**  &#10;&#10;- When subsystem is already simple.&#10;&#10;---&#10;&#10;### Flyweight&#10;&#10;Reduces memory usage by sharing data.&#10;&#10;**Example (Java):**&#10;```java&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class Flyweight {&#10;    private String shared;&#10;    public Flyweight(String shared) { this.shared = shared; }&#10;}&#10;&#10;public class FlyweightFactory {&#10;    private Map&lt;String, Flyweight&gt; flyweights = new HashMap&lt;&gt;();&#10;    public Flyweight getFlyweight(String shared) {&#10;        if (!flyweights.containsKey(shared)) {&#10;            flyweights.put(shared, new Flyweight(shared));&#10;        }&#10;        return flyweights.get(shared);&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When many objects share common data.&#10;&#10;**When not to use:**  &#10;&#10;- When objects are unique.&#10;&#10;---&#10;&#10;### Proxy&#10;&#10;Provides a surrogate for another object.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Subject {&#10;    void request();&#10;}&#10;&#10;public class RealSubject implements Subject {&#10;    public void request() { System.out.println(&quot;RealSubject&quot;); }&#10;}&#10;&#10;public class Proxy implements Subject {&#10;    private RealSubject real;&#10;    public Proxy(RealSubject real) { this.real = real; }&#10;    public void request() {&#10;        System.out.println(&quot;Proxy: Checking access&quot;);&#10;        real.request();&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For access control, lazy loading, logging.&#10;&#10;**When not to use:**  &#10;&#10;- When direct access is acceptable.&#10;&#10;---&#10;&#10;## Behavioral Patterns&#10;&#10;### Chain of Responsibility&#10;&#10;Passes a request along a chain of handlers.&#10;&#10;**Example (Java):**&#10;```java&#10;public abstract class Handler {&#10;    protected Handler next;&#10;    public void setNext(Handler next) { this.next = next; }&#10;    public void handle(String request) {&#10;        if (next != null) next.handle(request);&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When multiple objects can handle a request.&#10;&#10;**When not to use:**  &#10;&#10;- When only one handler is needed.&#10;&#10;---&#10;&#10;### Command&#10;&#10;Encapsulates a request as an object.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Command {&#10;    void execute();&#10;}&#10;&#10;public class LightOnCommand implements Command {&#10;    public void execute() { System.out.println(&quot;Light On&quot;); }&#10;}&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class Remote {&#10;    private List&lt;Command&gt; commands = new ArrayList&lt;&gt;();&#10;    public void addCommand(Command cmd) { commands.add(cmd); }&#10;    public void run() {&#10;        for (Command cmd : commands) { cmd.execute(); }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For undo/redo, queuing, logging.&#10;&#10;**When not to use:**  &#10;&#10;- When simple method calls suffice.&#10;&#10;---&#10;&#10;### Interpreter&#10;&#10;Defines a grammar and provides an interpreter.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Expression {&#10;    int interpret();&#10;}&#10;&#10;public class Number implements Expression {&#10;    private int value;&#10;    public Number(int value) { this.value = value; }&#10;    public int interpret() { return value; }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For languages, expressions, parsing.&#10;&#10;**When not to use:**  &#10;&#10;- For simple or infrequent grammar.&#10;&#10;---&#10;&#10;### Iterator&#10;&#10;Provides a way to access elements sequentially.&#10;&#10;**Example (Java):**&#10;```java&#10;import java.util.Iterator;&#10;import java.util.List;&#10;&#10;public class MyIterator implements Iterator&lt;String&gt; {&#10;    private List&lt;String&gt; collection;&#10;    private int index = 0;&#10;    public MyIterator(List&lt;String&gt; collection) { this.collection = collection; }&#10;    public boolean hasNext() { return index &lt; collection.size(); }&#10;    public String next() { return collection.get(index++); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to traverse a collection.&#10;&#10;**When not to use:**  &#10;&#10;- When direct access is sufficient.&#10;&#10;---&#10;&#10;### Mediator&#10;&#10;Encapsulates how objects interact.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Mediator {&#10;    void notify(Component sender, String event);&#10;}&#10;&#10;public class Component {&#10;    private Mediator mediator;&#10;    public Component(Mediator mediator) { this.mediator = mediator; }&#10;    public void doSomething() { mediator.notify(this, &quot;event&quot;); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When objects communicate in complex ways.&#10;&#10;**When not to use:**  &#10;&#10;- When communication is simple.&#10;&#10;---&#10;&#10;### Memento&#10;&#10;Captures and restores an object's state.&#10;&#10;**Example (Java):**&#10;```java&#10;public class Memento {&#10;    private String state;&#10;    public Memento(String state) { this.state = state; }&#10;    public String getState() { return state; }&#10;}&#10;&#10;public class Originator {&#10;    private String state;&#10;    public void setState(String state) { this.state = state; }&#10;    public Memento save() { return new Memento(state); }&#10;    public void restore(Memento memento) { state = memento.getState(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For undo/redo functionality.&#10;&#10;**When not to use:**  &#10;&#10;- When state is simple or not needed.&#10;&#10;---&#10;&#10;### Observer&#10;&#10;One-to-many dependency so dependents are notified of changes.&#10;&#10;**Example (Java):**&#10;```java&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public interface Observer {&#10;    void update();&#10;}&#10;&#10;public class Subject {&#10;    private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();&#10;    public void attach(Observer obs) { observers.add(obs); }&#10;    public void notifyObservers() {&#10;        for (Observer obs : observers) { obs.update(); }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For event handling, UI updates.&#10;&#10;**When not to use:**  &#10;&#10;- When only one object needs notification.&#10;&#10;---&#10;&#10;### State&#10;&#10;Alters behavior when internal state changes.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface State {&#10;    void handle();&#10;}&#10;&#10;public class Context {&#10;    private State state;&#10;    public Context(State state) { this.state = state; }&#10;    public void request() { state.handle(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When object behavior depends on state.&#10;&#10;**When not to use:**  &#10;&#10;- When state changes are rare.&#10;&#10;---&#10;&#10;### Strategy&#10;&#10;Encapsulates interchangeable algorithms.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Strategy {&#10;    int execute(int[] data);&#10;}&#10;&#10;public class SortStrategy implements Strategy {&#10;    public int execute(int[] data) {&#10;        java.util.Arrays.sort(data);&#10;        return data[0]; // Just for demonstration&#10;    }&#10;}&#10;&#10;public class Context {&#10;    private Strategy strategy;&#10;    public Context(Strategy strategy) { this.strategy = strategy; }&#10;    public int doTask(int[] data) { return strategy.execute(data); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When multiple algorithms are needed.&#10;&#10;**When not to use:**  &#10;&#10;- When only one algorithm is used.&#10;&#10;---&#10;&#10;### Template Method&#10;&#10;Defines the skeleton of an algorithm, deferring steps to subclasses.&#10;&#10;**Example (Java):**&#10;```java&#10;public abstract class AbstractClass {&#10;    public final void templateMethod() {&#10;        step1();&#10;        step2();&#10;    }&#10;    protected abstract void step1();&#10;    protected abstract void step2();&#10;}&#10;&#10;public class ConcreteClass extends AbstractClass {&#10;    protected void step1() { System.out.println(&quot;Step 1&quot;); }&#10;    protected void step2() { System.out.println(&quot;Step 2&quot;); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When algorithms have invariant steps.&#10;&#10;**When not to use:**  &#10;&#10;- When steps never change.&#10;&#10;---&#10;&#10;### Visitor&#10;&#10;Represents an operation to be performed on elements of an object structure.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Visitor {&#10;    void visit(Element element);&#10;}&#10;&#10;public interface Element {&#10;    void accept(Visitor visitor);&#10;}&#10;&#10;public class ConcreteElement implements Element {&#10;    public void accept(Visitor visitor) { visitor.visit(this); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to perform operations on object structures.&#10;&#10;**When not to use:**  &#10;&#10;- When object structure rarely changes.&#10;&#10;---&#10;&#10;## Summary&#10;&#10;The 23 core design patterns (Gang of Four) are essential tools for software engineers.  &#10;They provide proven solutions to common problems in software design, improve code maintainability, and are frequently discussed in interviews.  &#10;Understanding these patterns helps you write flexible, scalable, and robust code." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/content/posts/system_design/jee_design_patterns.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/content/posts/system_design/jee_design_patterns.md" />
              <option name="originalContent" value="+++&#10;date = '2024-05-03T12:44:47+10:00'&#10;draft = false&#10;title = 'JEE Design Patterns'&#10;tags = ['JEE Design Patterns', 'Interview']&#10;+++&#10;&#10;About JEE Design Patterns.&#10;&#10;## Table of Contents&#10;" />
              <option name="updatedContent" value="+++&#10;date = '2025-05-03T12:44:47+10:00'&#10;draft = false&#10;title = 'JEE Design Patterns'&#10;tags = ['JEE Design Patterns', 'Interview']&#10;+++&#10;&#10;JEE design patterns are specialized solutions for enterprise Java applications. They address scalability, maintainability, and performance challenges in distributed systems, helping developers build robust, modular, and efficient enterprise-grade software.&#10;&#10;## Table of Contents&#10;&#10;- [Presentation Tier Patterns](#presentation-tier-patterns)&#10;  - [Intercepting Filter](#intercepting-filter)&#10;  - [Front Controller](#front-controller)&#10;  - [View Helper](#view-helper)&#10;  - [Composite View](#composite-view)&#10;- [Business Tier Patterns](#business-tier-patterns)&#10;  - [Business Delegate](#business-delegate)&#10;  - [Session Facade](#session-facade)&#10;  - [Application Service](#application-service)&#10;  - [Service Locator](#service-locator)&#10;  - [Transfer Object](#transfer-object)&#10;- [Integration Tier Patterns](#integration-tier-patterns)&#10;  - [Data Access Object (DAO)](#data-access-object-dao)&#10;  - [Service Activator](#service-activator)&#10;  - [Web Service Broker](#web-service-broker)&#10;- [Summary](#summary)&#10;&#10;---&#10;&#10;## Presentation Tier Patterns&#10;&#10;### Intercepting Filter&#10;&#10;Provides centralized request pre-processing and post-processing.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Filter {&#10;    void execute(String request);&#10;}&#10;&#10;public class AuthenticationFilter implements Filter {&#10;    public void execute(String request) {&#10;        System.out.println(&quot;Authenticating request: &quot; + request);&#10;    }&#10;}&#10;&#10;public class FilterChain {&#10;    private List&lt;Filter&gt; filters = new ArrayList&lt;&gt;();&#10;    public void addFilter(Filter filter) { filters.add(filter); }&#10;    public void execute(String request) {&#10;        for (Filter filter : filters) { filter.execute(request); }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- When you need reusable request processing logic (logging, authentication).&#10;&#10;**When not to use:**  &#10;- When processing logic is simple or not reusable.&#10;&#10;---&#10;&#10;### Front Controller&#10;&#10;Centralizes request handling to improve control and flexibility.&#10;&#10;**Example (Java):**&#10;```java&#10;public class FrontController {&#10;    public void dispatchRequest(String request) {&#10;        if (&quot;HOME&quot;.equals(request)) {&#10;            System.out.println(&quot;Displaying Home Page&quot;);&#10;        } else {&#10;            System.out.println(&quot;404 Not Found&quot;);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- When you want a single entry point for requests.&#10;&#10;**When not to use:**  &#10;- For very simple applications.&#10;&#10;---&#10;&#10;### View Helper&#10;&#10;Separates business logic from view rendering.&#10;&#10;**Example (Java):**&#10;```java&#10;public class ViewHelper {&#10;    public String formatDate(Date date) {&#10;        return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(date);&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- When you want to keep views clean and reusable.&#10;&#10;**When not to use:**  &#10;- When formatting logic is trivial.&#10;&#10;---&#10;&#10;### Composite View&#10;&#10;Creates views from modular, reusable subviews.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface View {&#10;    void render();&#10;}&#10;&#10;public class HeaderView implements View {&#10;    public void render() { System.out.println(&quot;Header&quot;); }&#10;}&#10;&#10;public class CompositeView implements View {&#10;    private List&lt;View&gt; views = new ArrayList&lt;&gt;();&#10;    public void addView(View view) { views.add(view); }&#10;    public void render() {&#10;        for (View view : views) { view.render(); }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- For complex UIs with reusable components.&#10;&#10;**When not to use:**  &#10;- For simple, static views.&#10;&#10;---&#10;&#10;## Business Tier Patterns&#10;&#10;### Business Delegate&#10;&#10;Decouples presentation and business logic.&#10;&#10;**Example (Java):**&#10;```java&#10;public class BusinessService {&#10;    public void doTask() { System.out.println(&quot;Business logic executed&quot;); }&#10;}&#10;&#10;public class BusinessDelegate {&#10;    private BusinessService service = new BusinessService();&#10;    public void executeTask() { service.doTask(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- When you want to hide business logic complexity from the presentation tier.&#10;&#10;**When not to use:**  &#10;- When business logic is simple.&#10;&#10;---&#10;&#10;### Session Facade&#10;&#10;Provides a unified interface to a set of business services.&#10;&#10;**Example (Java):**&#10;```java&#10;public class OrderService { public void placeOrder() {} }&#10;public class PaymentService { public void processPayment() {} }&#10;&#10;public class SessionFacade {&#10;    private OrderService orderService = new OrderService();&#10;    private PaymentService paymentService = new PaymentService();&#10;    public void completeOrder() {&#10;        orderService.placeOrder();&#10;        paymentService.processPayment();&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- When you want to reduce network calls and simplify client interaction.&#10;&#10;**When not to use:**  &#10;- When only one service is involved.&#10;&#10;---&#10;&#10;### Application Service&#10;&#10;Coordinates business logic across multiple operations.&#10;&#10;**Example (Java):**&#10;```java&#10;public class ApplicationService {&#10;    public void performBusinessOperation() {&#10;        // Business logic spanning multiple domain objects&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- For complex business workflows.&#10;&#10;**When not to use:**  &#10;- For simple, single-step operations.&#10;&#10;---&#10;&#10;### Service Locator&#10;&#10;Centralizes service lookup and management.&#10;&#10;**Example (Java):**&#10;```java&#10;public class ServiceLocator {&#10;    private static Map&lt;String, Object&gt; services = new HashMap&lt;&gt;();&#10;    public static Object getService(String name) { return services.get(name); }&#10;    public static void registerService(String name, Object service) { services.put(name, service); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- When you need to decouple service consumers from service creation.&#10;&#10;**When not to use:**  &#10;- When dependency injection is preferred.&#10;&#10;---&#10;&#10;### Transfer Object&#10;&#10;Encapsulates data for transfer between layers.&#10;&#10;**Example (Java):**&#10;```java&#10;public class CustomerDTO {&#10;    private String name;&#10;    private String email;&#10;    // getters and setters&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- When transferring multiple data fields between layers.&#10;&#10;**When not to use:**  &#10;- For simple, single-field transfers.&#10;&#10;---&#10;&#10;## Integration Tier Patterns&#10;&#10;### Data Access Object (DAO)&#10;&#10;Abstracts and encapsulates all access to the data source.&#10;&#10;**Example (Java):**&#10;```java&#10;public class CustomerDAO {&#10;    public CustomerDTO findCustomerById(int id) {&#10;        // DB lookup logic&#10;        return new CustomerDTO();&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- When you want to separate persistence logic from business logic.&#10;&#10;**When not to use:**  &#10;- For trivial data access.&#10;&#10;---&#10;&#10;### Service Activator&#10;&#10;Enables asynchronous invocation of business services.&#10;&#10;**Example (Java):**&#10;```java&#10;public class ServiceActivator {&#10;    public void activateService(Runnable serviceTask) {&#10;        new Thread(serviceTask).start();&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- For asynchronous processing.&#10;&#10;**When not to use:**  &#10;- For synchronous, simple calls.&#10;&#10;---&#10;&#10;### Web Service Broker&#10;&#10;Centralizes and manages web service interactions.&#10;&#10;**Example (Java):**&#10;```java&#10;public class WebServiceBroker {&#10;    public void callService(String endpoint) {&#10;        System.out.println(&quot;Calling web service at &quot; + endpoint);&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- For integrating multiple web services.&#10;&#10;**When not to use:**  &#10;- For direct, simple web service calls.&#10;&#10;---&#10;&#10;## Summary&#10;&#10;JEE design patterns help solve common problems in enterprise Java applications.  &#10;They improve scalability, maintainability, and modularity, and are essential knowledge for interviews and building robust distributed systems." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/content/posts/system_design/system_design.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/content/posts/system_design/system_design.md" />
              <option name="originalContent" value="+++&#10;date = '2025-05-03T12:44:47+10:00'&#10;draft = false&#10;title = 'System Design Interview Concepts'&#10;tags = ['Event Driven Architecture', 'Microservices', 'Interview']&#10;+++&#10;&#10;System design is a critical aspect of software engineering that involves creating scalable, reliable, and efficient systems. This document explores key concepts and strategies required for designing robust systems, including networking, databases, scalability, caching, and modern architectural patterns. It serves as a comprehensive guide for understanding the foundational and advanced principles of system design.&#10;&#10;## Table of Contents&#10;&#10;- [Approach](#approach)&#10;- [HTTPS Certificates in System Design](#https-certificates-in-system-design)&#10;- [Networking and Communication](#networking-and-communication)&#10;  - [Client Server Architecture](#client-server-architecture)&#10;  - [IP Address](#ip-address)&#10;  - [DNS](#dns)&#10;  - [Proxy/Reverse Proxy](#proxyreverse-proxy)&#10;  - [Latency](#latency)&#10;  - [HTTP/HTTPS and MASL (Mutual Authentication Security Layers)](#httphttps-and-masl-mutual-authentication-security-layers)&#10;  - [WebSockets](#websockets)&#10;  - [Webhooks](#webhooks)&#10;- [APIs and Integration](#apis-and-integration)&#10;  - [APIs](#apis)&#10;  - [REST API](#rest-api)&#10;  - [GraphQL](#graphql)&#10;  - [API Gateway](#api-gateway)&#10;  - [Idempotency](#idempotency)&#10;  - [REST and REST Maturity Model](#rest-and-rest-maturity-model)&#10;- [Databases and Storage](#databases-and-storage)&#10;  - [Databases](#databases)&#10;  - [SQL vs NoSQL vs Object Store](#sql-vs-nosql-vs-object-store)&#10;  - [Database Indexing](#database-indexing)&#10;  - [Replication](#replication)&#10;  - [Sharding](#sharding)&#10;  - [Vertical Partitioning](#vertical-partitioning)&#10;  - [Caching](#caching)&#10;  - [ACID vs BASE](#acid-vs-base)&#10;  - [Normalization vs Denormalization](#normalization-vs-denormalization)&#10;  - [CAP Theorem](#cap-theorem)&#10;  - [Blob Storage](#blob-storage)&#10;- [Scalability and Performance](#scalability-and-performance)&#10;  - [Vertical and Horizontal Scaling](#vertical-and-horizontal-scaling)&#10;  - [Algorithmic Scaling](#algorithmic-scaling)&#10;  - [The Scale Cube](#2️⃣-distributed-scaling--the-scale-cube)&#10;  - [Additional Scaling Techniques](#3️⃣-additional-scaling-techniques-beyond-the-cube)&#10;  - [Layered View](#layered-view)&#10;  - [Examples of Big O Notation in Java](#examples-of-big-o-notation-in-java)&#10;  - [Load Balancers](#load-balancers)&#10;  - [Rate Limiting](#rate-limiting)&#10;  - [Content Delivery Optimization](#content-delivery-optimization)&#10;  - [Zero Downtime Deployment](#zero-downtime-deployment)&#10;- [Common Design Patterns and Architecture](#common-design-patterns-and-architecture)&#10;  - [Event-Driven Architecture](#event-driven-architecture)&#10;  - [Data Partitioning Strategies](#data-partitioning-strategies)&#10;  - [Eventual Consistency](#eventual-consistency)&#10;  - [Leader Election](#leader-election)&#10;  - [Circuit Breaker Pattern](#circuit-breaker-pattern)&#10;  - [Throttling and Backpressure](#throttling-and-backpressure)&#10;  - [Service Discovery](#service-discovery)&#10;  - [Microservices](#microservices)&#10;  - [Message Queues](#message-queues)&#10;- [Monitoring, Resiliency, and Security](#monitoring-resiliency-and-security)&#10;  - [Monitoring and Observability](#monitoring-and-observability)&#10;  - [Data Compression](#data-compression)&#10;  - [Authentication and Authorization](#authentication-and-authorization)&#10;  - [Data Backup and Recovery](#data-backup-and-recovery)&#10;  - [Chaos Engineering](#chaos-engineering)&#10;- [Development and Deployment](#development-and-deployment)&#10;  - [Concurrency Control](#concurrency-control)&#10;  - [Immutable Infrastructure](#immutable-infrastructure)&#10;  - [Blue-Green Deployment](#blue-green-deployment)&#10;- [Theoretical Concepts](#theoretical-concepts)&#10;  - [Search Systems](#search-systems)&#10;- [Data Processing](#data-processing)&#10;  - [Data Streaming](#data-streaming)&#10;- [Miscellaneous](#miscellaneous)&#10;  - [Rate Shaping](#rate-shaping)&#10;&#10;## Approach&#10;- Do not directly start designing; every problem is unique. Think of every problem as designing and building a bridge. You must understand:&#10;  - **Whom or What you are building for**  &#10;    - target users or audience and their count.  &#10;    - Expected traffic or load  &#10;    - User behavior e.g. Celebrity Problem &#10;    - Interaction patterns.  &#10;    - Account for user demographics and geographic distribution.  &#10;    - Evaluate the specific needs or goals of the users.&#10;  - **Where you are building** (the environment or constraints).&#10;  - **How you build**.&#10;&#10;## Steps:&#10;- **Understand your use case**: Clearly define the problem and its requirements.&#10;- **Ask the right questions**: Gather Necessary details, NO assumptions.&#10;- **Decide the modules**: Break the big problem into smaller, manageable parts (e.g., defining context boundaries). Ask which they want you to tackle first.&#10;- **Design with key considerations**:  Address other critical &quot;ilities&quot;&#10;     - **Availability**&#10;     - **Reliability**&#10;     - **Maintainability**&#10;     - **Performance**&#10;     - **Scalability**&#10;     - **Cost-efficiency**&#10;     - **Security**&#10;     - **Flexibility**&#10;     (Always remind yourself - everything fails)&#10;---&#10;## HTTPS Certificates in System Design&#10;&#10;In system design, **HTTPS certificates** are essential for securing communication between clients (e.g., web browsers, mobile apps) and servers. They are used to encrypt data, verify server identity, and ensure secure communication channels in modern web and microservice architectures.&#10;&#10;---&#10;&#10;## Key Points about HTTPS Certificates&#10;&#10;### 1. **What is an HTTPS Certificate?**&#10;- **HTTPS certificates** are **X.509 certificates** used in **TLS (Transport Layer Security)** for encrypting and securing HTTP traffic.&#10;- They contain the **public key** of a server, and are signed by a trusted **Certificate Authority (CA)** to confirm the authenticity of the server.&#10;&#10;### 2. **Role in HTTPS Communication:**&#10;- **Encryption**: HTTPS certificates use **TLS** to encrypt data in transit, ensuring that information exchanged between client and server is private and secure.&#10;- **Authentication**: The certificate proves the server's identity, assuring clients that they are communicating with the correct, trusted server.&#10;- **Data Integrity**: It ensures that data cannot be tampered with while in transit.&#10;&#10;---&#10;&#10;## HTTPS Flow in System Design&#10;&#10;1. **DNS Resolution** → The domain name (e.g., `example.com`) is resolved to an IP address.&#10;2. **TCP Handshake** → A 3-way handshake is established between the client and server.&#10;3. **TLS Handshake**:&#10;   - The client requests a secure connection and receives the server's certificate.&#10;   - The client verifies the certificate's authenticity (checking the CA and validity period).&#10;   - The client and server exchange keys to encrypt further communication.&#10;4. **Secure Communication**: The HTTP request and response occur over the encrypted TLS channel.&#10;5. **Connection Termination**: Once communication is complete, the connection is securely closed.&#10;&#10;---&#10;&#10;## HTTPS Certificate Components&#10;&#10;1. **Public Key**: Used for encryption and establishing a secure connection.&#10;2. **Issuer**: The Certificate Authority (CA) that issued the certificate.&#10;3. **Subject**: The entity (e.g., website, server) being identified by the certificate.&#10;4. **Validity Period**: The certificate’s expiration date.&#10;5. **Signature**: A digital signature from the CA, ensuring the certificate's authenticity.&#10;6. **Extensions**: Additional metadata, such as **Subject Alternative Names (SANs)**, which allow a single certificate to cover multiple domains.&#10;&#10;---&#10;&#10;## Use Cases in System Design&#10;&#10;### 1. **Web Applications**&#10;- HTTPS certificates are used to secure user data, such as login credentials and payment details, during transmission between the browser and server.&#10;- **SSL/TLS** ensures that users can trust the site and prevents **man-in-the-middle attacks**.&#10;&#10;### 2. **API Security**&#10;- APIs use HTTPS certificates to secure communication between clients and services, ensuring that data transmitted between services is encrypted and authenticated.&#10;- **API Gateways** often enforce HTTPS for all incoming and outgoing traffic to secure internal and external communications.&#10;&#10;### 3. **Microservices Communication**&#10;- In microservices architectures, services communicate securely using **TLS** certificates.&#10;- Certificates can be used with **mTLS (Mutual TLS)**, where both the client and the server authenticate each other.&#10;- This is common for ensuring trust between services within a **private network**.&#10;&#10;### 4. **Certificate Pinning**&#10;- To prevent attacks, some systems implement **certificate pinning** to ensure that only a specific, trusted certificate can be used, even if it’s issued by a trusted CA.&#10;&#10;---&#10;&#10;## Design Considerations for HTTPS Certificates&#10;&#10;### 1. **Certificate Management:**&#10;   - **Renewal**: Certificates must be renewed periodically (typically every 1-2 years).&#10;   - **Revocation**: Certificates must be revoked if compromised, and Certificate Revocation Lists (CRLs) or **OCSP (Online Certificate Status Protocol)** can be used to check the certificate status.&#10;&#10;### 2. **Load Balancers and API Gateways:**&#10;   - **SSL Termination**: In many architectures, HTTPS connections are terminated at a **load balancer** or **API Gateway**. This means the secure connection between the client and the gateway is decrypted, and the communication between services may continue over plain HTTP or encrypted further.&#10;&#10;### 3. **Security Best Practices:**&#10;   - Use strong encryption algorithms (e.g., **TLS 1.2 or 1.3**).&#10;   - **Perfect Forward Secrecy (PFS)** should be enabled to ensure that past sessions are not compromised even if the server's private key is leaked.&#10;   - Regularly update certificates and private keys.&#10;   - Store private keys securely and limit access.&#10;&#10;---&#10;&#10;## Key Takeaways for System Design&#10;&#10;- **HTTPS certificates** are crucial for securing **web traffic** and **API communications** in modern system architectures.&#10;- They ensure **confidentiality**, **integrity**, and **authentication** between clients and servers.&#10;- Proper **certificate management** (renewal, revocation, etc.) is key for maintaining security.&#10;- **SSL/TLS termination** at **API Gateways** or **load balancers** can simplify management but must be carefully designed to ensure traffic is encrypted when needed.&#10;- **mTLS** can be used for mutual authentication between services, adding an additional layer of security in microservices architectures.&#10;&#10;&#10;## Networking and Communication&#10;### Client Server Architecture&#10;### IP Address&#10;### DNS&#10;### Proxy/Reverse Proxy&#10;### Latency&#10;### HTTP/HTTPS and MASL (Mutual Authentication Security Layers)&#10;&#10;##  1. HTTP / HTTPS in System Design&#10;&#10;###  HTTP&#10;- Stateless protocol for transferring hypertext and media between client and server.&#10;- Operates over **TCP** (usually port **80**).&#10;- Requests consist of **methods** (GET, POST, PUT, DELETE), **headers**, and optionally a **body**.&#10;- No built-in encryption → data sent in plaintext.&#10;&#10;###  HTTPS&#10;- HTTP over **TLS (Transport Layer Security)** → operates on port **443**.&#10;&#10;**Provides:**&#10;-  **Confidentiality:** Encrypts data.&#10;- ️ **Integrity:** Detects tampering.&#10;-  **Authentication:** Validates server identity via SSL/TLS certificates.&#10;&#10;**Used In:**&#10;- Web apps  &#10;- REST APIs  &#10;- Microservices communication  &#10;- IoT and mobile devices  &#10;&#10;##  Details of handshake &#10;&lt;img width=&quot;3000&quot; height=&quot;3336&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/2e8bf550-4932-4c84-a2ca-b3034b57c1f8&quot; /&gt;&#10;&#10;### 1. Client Hello&#10;The client initiates the handshake by sending:&#10;- A list of supported **cipher suites** (algorithms for encryption, key exchange, etc.).&#10;- A **`client_random`** value — a 32-byte random number.&#10;&#10;####  Why `client_random`?&#10;- Adds **entropy** to the key derivation process.&#10;- Ensures each session is **unique**, even if the same algorithms are used.&#10;- Helps prevent **replay attacks** by making the handshake unpredictable.&#10;&#10;### 2. Server Hello + Certificate&#10;The server responds with:&#10;- A selected **cipher suite** from the client's list.&#10;- Its own **`server_random`** value.&#10;- A **digital certificate** (usually X.509) containing its public key and identity.&#10;&#10;####  Why the Certificate?&#10;- Allows the client to **authenticate** the server.&#10;- The client checks:&#10;  - Is the certificate signed by a trusted Certificate Authority (CA)?&#10;  - Is it still valid (not expired)?&#10;  - Does the domain match?&#10;&#10;### 3. Key Exchange and Session Key Derivation&#10;Depending on the chosen cipher suite (e.g., ECDHE), the client and server:&#10;- Exchange **ephemeral public keys**.&#10;- Each side uses its private key and the other’s public key to compute a **shared secret**.&#10;- They use a **Key Derivation Function (KDF)** to combine:&#10;  - The shared secret&#10;  - `client_random`&#10;  - `server_random`&#10;  → to derive **symmetric session keys**.&#10;####  How the Shared Secret Is Computed in ECDHE&#10;&#10; Key Generation&#10;**Client generates:**&#10;&#10;- Private key: a&#10;- Public key: A = aG&#10;**Server generates:**&#10;&#10;- Private key: b&#10;- Public key: B = bG&#10;Here, G is a known base point on the elliptic curve.&#10;- **Client computes**:  &#10;  `S = a * B = a * (bG) = abG`&#10;- **Server computes**:  &#10;  `S = b * A = b * (aG) = abG`&#10;✅ Both arrive at the **same shared secret** `S = abG`.&#10;&#10;####  Why Ephemeral Keys (ECDHE)?&#10;- Provides **forward secrecy**: even if long-term keys are compromised, past sessions remain secure.&#10;- Ensures that each session has **unique encryption keys**.&#10;&#10;### 4. Finished Messages&#10;- Both sides send encrypted &quot;Finished&quot; messages to confirm that the handshake was successful.&#10;- From this point on, all communication is encrypted using the derived session keys.&#10;&#10;---&#10;&#10;###  Summary of Key Components&#10;&#10;| Component        | Purpose                                      |&#10;|------------------|----------------------------------------------|&#10;| `client_random`  | Adds entropy, uniqueness, and prevents replay attacks |&#10;| `server_random`  | Same as above, from the server side          |&#10;| Certificate      | Authenticates the server (and optionally the client) |&#10;| Ephemeral Keys   | Used to compute a shared secret securely     |&#10;| Session Keys     | Encrypt and authenticate all further communication |&#10;&#10;&#10;---&#10;&#10;##  What is Mutual Authentication (mTLS)?&#10;&#10;###  Common Use Cases&#10;&#10;| Use Case                      | Why Use mTLS?                                     |&#10;|------------------------------|---------------------------------------------------|&#10;| Service-to-service (microservices) | Ensure only trusted services communicate          |&#10;| APIs for fintech / healthcare | Regulatory compliance (HIPAA, PCI-DSS)            |&#10;| IoT Devices ↔ Cloud          | Authenticate individual devices securely          |&#10;| Enterprise internal apps     | Add trust within a private/internal network       |&#10;&#10;##  Details of handshake &#10;&lt;img width=&quot;1452&quot; height=&quot;2322&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/93556c5e-3e0b-42a2-90e0-aae7c0ad1da6&quot; /&gt;&#10;&#10;### 1. Client Hello&#10;- Client sends supported cipher suites and `client_random`.&#10;&#10;### 2. Server Hello + Certificate&#10;- Server responds with:&#10;  - Chosen cipher suite&#10;  - `server_random`&#10;  - Server certificate&#10;&#10;### 3. Server Requests Client Certificate&#10;- Server sends a `CertificateRequest` message.&#10;&#10;### 4. Client Sends Certificate&#10;- Client sends its certificate for authentication.&#10;&#10;### 5. Key Exchange&#10;- Both sides exchange ephemeral public keys (e.g., via ECDHE).&#10;- Each side computes the shared secret using its private key and the other’s public key.&#10;&#10;### 6. Certificate Verification&#10;- Server verifies the client’s certificate.&#10;- Client verifies the server’s certificate.&#10;&#10;### 7. Finished Messages&#10;- Both sides send encrypted &quot;Finished&quot; messages.&#10;- Secure communication begins using derived session keys.&#10;&#10;&#10;&#10;### WebSockets&#10;---&#10;### Webhooks&#10;---&#10;## APIs and Integration&#10;### APIs&#10;---&#10;### REST API&#10;---&#10;### GraphQL&#10;---&#10;### API Gateway&#10;---&#10;### Idempotency&#10;&#10;## REST and REST Maturity Model&#10;### What is REST?&#10;REST (Representational State Transfer) is an architectural style for designing networked applications. It relies on stateless communication and standard HTTP methods to enable interaction between clients and servers. RESTful APIs are widely used for their simplicity, scalability, and compatibility with web standards.&#10;&#10;Key principles of REST include:&#10;- **Statelessness**: Each request from a client to a server must contain all the information needed to understand and process the request.&#10;- **Client-Server Architecture**: Separation of concerns between the client and server, allowing them to evolve independently.&#10;- **Uniform Interface**: A consistent and standardized way of interacting with resources.&#10;- **Resource-Based**: Resources are identified using URIs (Uniform Resource Identifiers).&#10;- **Cacheability**: Responses must define whether they are cacheable to improve performance.&#10;- **Layered System**: The architecture can have multiple layers, such as load balancers and proxies, to improve scalability and security.&#10;&#10;### REST Maturity Model&#10;The REST Maturity Model, introduced by Leonard Richardson, defines levels of maturity for RESTful APIs. It helps evaluate how closely an API adheres to REST principles.&#10;&#10;![](../REST.png)&#10;&#10;#### Level 0: The Swamp of POX&#10;- APIs at this level use a single URI and rely on HTTP POST for all interactions.&#10;- They often resemble RPC (Remote Procedure Call) or SOAP (Simple Object Access Protocol).&#10;&#10;#### Level 1: Resources&#10;- Introduces the concept of resources, each identified by a unique URI.&#10;- HTTP methods are not yet fully utilized.&#10;&#10;#### Level 2: HTTP Verbs&#10;- Uses standard HTTP methods (GET, POST, PUT, DELETE, etc.) to perform operations on resources.&#10;- Improves clarity and aligns with REST principles.&#10;&#10;#### Level 3: Hypermedia Controls (HATEOAS)&#10;- Hypermedia as the Engine of Application State (HATEOAS) is implemented.&#10;- Clients can navigate the API dynamically using links provided in responses.&#10;- This level achieves full REST maturity by enabling discoverability and self-documentation.&#10;&#10;### Benefits of REST Maturity&#10;- **Scalability**: Higher levels of maturity improve scalability by leveraging HTTP standards.&#10;- **Interoperability**: Adherence to REST principles ensures compatibility across different platforms.&#10;- **Maintainability**: A well-designed RESTful API is easier to maintain and extend.&#10;- **Discoverability**: HATEOAS enables clients to discover available actions dynamically.&#10;&#10;By understanding and applying the REST Maturity Model, developers can design APIs that are robust, scalable, and aligned with modern web standards.&#10;&#10;---&#10;## Databases and Storage&#10;### Databases&#10;---&#10;### SQL vs NoSQL vs Object Store&#10;&#10;When designing a system, choosing the right data storage solution is crucial. The three main categories are **SQL databases**, **NoSQL databases**, and **Object Stores**. Each serves different use cases and has unique characteristics.&#10;&#10;#### SQL Databases (Relational Databases)&#10;&#10;- **Examples:** MySQL, PostgreSQL, Oracle, Microsoft SQL Server&#10;- **Data Model:** Structured, tabular data with predefined schemas (tables, rows, columns)&#10;- **Query Language:** SQL (Structured Query Language)&#10;- **Transactions:** Strong ACID guarantees (Atomicity, Consistency, Isolation, Durability)&#10;- **Use Cases:** Applications requiring complex queries, joins, and strong consistency (e.g., banking, ERP, CRM)&#10;- **Strengths:** Data integrity, complex querying, relationships, mature ecosystem&#10;- **Limitations:** Vertical scaling, rigid schema, less suited for unstructured or rapidly evolving data&#10;&#10;#### NoSQL Databases&#10;&#10;- **Examples:** MongoDB (Document), Cassandra (Wide-column), Redis (Key-Value), Neo4j (Graph)&#10;- **Data Model:** Flexible, can be document, key-value, column-family, or graph-based&#10;- **Schema:** Schema-less or dynamic schemas; can handle semi-structured or unstructured data&#10;- **Transactions:** Typically BASE properties (Basically Available, Soft state, Eventually consistent)&#10;- **Use Cases:** High scalability, large volumes of diverse data, real-time analytics, IoT, social networks&#10;- **Strengths:** Horizontal scaling, flexible data models, high write/read throughput&#10;- **Limitations:** Weaker consistency (eventual consistency), limited support for complex joins, less mature tooling&#10;&#10;#### Object Store&#10;&#10;- **Examples:** Amazon S3, Google Cloud Storage, Azure Blob Storage, MinIO&#10;- **Data Model:** Stores data as objects (blobs) with metadata and a unique identifier; no schema or tables&#10;- **Access:** Accessed via APIs (REST, SDKs); not a database—optimized for storing and retrieving large files&#10;- **Transactions:** No ACID/BASE guarantees; eventual consistency for some operations&#10;- **Use Cases:** Storing unstructured data (images, videos, backups, logs, large files), data lakes, static website hosting&#10;- **Strengths:** Virtually unlimited scalability, low cost for large data, durability, global access&#10;- **Limitations:** Not suitable for transactional data or complex queries; eventual consistency; slower for small, frequent reads/writes&#10;&#10;#### Comparison Table&#10;&#10;| Feature         | SQL (Relational)         | NoSQL                    | Object Store                |&#10;|-----------------|-------------------------|--------------------------|-----------------------------|&#10;| **Data Model**  | Tables (rows/columns)   | Flexible (JSON, KV, etc) | Objects (blobs + metadata)  |&#10;| **Schema**      | Fixed                   | Dynamic/Schema-less      | None                        |&#10;| **Query**       | SQL                     | Varies (NoSQL APIs)      | API (REST/S3)               |&#10;| **Transactions**| ACID                    | BASE (usually)           | None                        |&#10;| **Scaling**     | Vertical (mostly)       | Horizontal               | Horizontal                  |&#10;| **Best For**    | Structured, relational  | Semi/unstructured, scale | Unstructured, large files   |&#10;| **Examples**    | MySQL, PostgreSQL       | MongoDB, Cassandra       | S3, GCS, Azure Blob         |&#10;&#10;**Summary:**  &#10;- Use **SQL** for structured data and strong consistency.&#10;- Use **NoSQL** for flexible, scalable, high-throughput needs.&#10;- Use **Object Store** for unstructured, large-scale file storage—not as a database.&#10;&#10;---&#10;### Database Indexing&#10;---&#10;### Replication&#10;---&#10;### Sharding&#10;---&#10;### Vertical Partitioning&#10;---&#10;### Caching&#10;&#10;Caching is the process of storing frequently accessed data in a temporary storage layer to improve system performance and reduce latency. &#10;&#10;#### Advantages of Caching&#10;&#10;1. **Improved Performance**: Reduces response time by serving data from faster storage layers (e.g., memory).  &#10;&#10;2. **Reduced Latency**: Minimizes delays in data retrieval, enhancing user experience.  &#10;&#10;3. **Lower Database Load**: Decreases the number of direct queries to the database, reducing resource usage.  &#10;&#10;4. **Scalability**: Helps handle increased traffic by offloading requests from the primary data source.  &#10;&#10;5. **Cost Efficiency**: Reduces operational costs by optimizing resource utilization.  &#10;&#10;#### Disadvantages of Caching&#10;&#10;1. **Data Staleness**: Cached data may become outdated if not properly invalidated or refreshed.  &#10;&#10;2. **Complexity**: Implementing and managing caching layers adds complexity to the system.  &#10;&#10;3. **Cache Misses**: If data is not found in the cache, it can lead to slower performance as the system falls back to the original data source.  &#10;&#10;4. **Memory Overhead**: Caching requires additional memory, which can increase infrastructure costs.  &#10;&#10;5. **Consistency Challenges**: Ensuring data consistency between the cache and the source of truth can be difficult.  &#10;&#10;#### Strategies&#10;&#10;1. **Cache-Aside**: The application checks the cache first. If the data is not found, it fetches from the database and updates the cache. Commonly used for read-heavy workloads.  &#10;&#10;2. **Write-Through**: Data is written to the cache and the database simultaneously. Ensures data consistency but may introduce higher write latency.  &#10;&#10;3. **Write-Behind**: Data is written to the cache first and asynchronously updated in the database. Improves write performance but risks data loss during failures.  &#10;&#10;4. **Read-Through**: The application interacts only with the cache. If the data is not in the cache, the cache fetches it from the database. Simplifies application logic but adds complexity to the caching layer.  &#10;&#10;#### Measuring Cache Effectiveness&#10;&#10;1. **Calculate the Cache Hit Rate**: Measure the percentage of requests served from the cache versus the total requests. A high hit rate indicates effective caching.  &#10;&#10;2. **Analyze Cache Eviction Rate**: Monitor how often data is evicted from the cache due to capacity limits. Optimize cache size and eviction policies to reduce unnecessary evictions.  &#10;&#10;3. **Monitor Data Consistency**: Ensure that cached data remains consistent with the source of truth (e.g., database). Use appropriate invalidation and expiration mechanisms.  &#10;&#10;4. **Determine the Right Cache Expiration Time**: Set expiration times based on data usage patterns and freshness requirements. Avoid stale data while minimizing unnecessary cache misses.&#10;&#10;#### Example Use Cases for Caching&#10;&#10;1. **URL Shortener**: Cache `ShortCode → URL` mappings. Strategy: LRU for frequently accessed URLs.&#10;&#10;2. **User Profile Service**: Cache user profiles with TTL for frequent reads. Challenge: Cache invalidation and consistency.&#10;&#10;3. **Weather Forecast API**: Cache responses based on `city+date`. Set TTL based on forecast freshness.&#10;&#10;4. **Rate Limiter Service**: Cache token bucket or sliding window counters per user. Use Redis or in-memory store with expiration.&#10;&#10;5. **Product Catalog**: Cache product details at edge/CDN. Strategy: Write-through or refresh-on-write.&#10;&#10;6. **Twitter Feed**: Cache user timelines and precompute recent tweets. Eviction policy: LRU or LFU.&#10;&#10;7. **Geolocation Service**: Cache frequently accessed IP ranges. Use TTL for DNS/IP lookups.&#10;&#10;8. **Session Management**: Store sessions in Redis with TTL. Trade-off: In-memory vs database storage.&#10;&#10;9. **Distributed Cache System**: Handle replication vs partitioning. Prevent hot keys and cache stampede.&#10;&#10;10. **Online Code Editor**: Cache user preferences and recent submissions. Use client-side and server-side caching.&#10;&#10;#### References&#10;&#10;- [Cache Strategies - Medium](https://medium.com/@mmoshikoo/cache-strategies-996e91c80303)&#10;&#10;---&#10;### ACID vs BASE&#10;&#10;#### ACID Properties&#10;ACID stands for Atomicity, Consistency, Isolation, and Durability. These properties are essential for traditional relational databases to ensure reliable transactions:&#10;- **Atomicity**: Ensures that a transaction is all-or-nothing. If one part fails, the entire transaction is rolled back.&#10;- **Consistency**: Guarantees that a transaction brings the database from one valid state to another, maintaining all defined rules.Always preserve the data integrity.&#10;- **Isolation**: Ensures that concurrent transactions do not interfere with each other. Don't step on each other shoes. The various problems&#10;&#10;  | Isolation Level      | Dirty Reads | Non-Repeatable Reads | Phantom Reads | Description |&#10;  |----------------------|-------------|-----------------------|----------------|-------------|&#10;  | **Read Uncommitted** | ✅ Allowed  | ✅ Allowed            | ✅ Allowed     | Minimal isolation, allows all anomalies. |&#10;  | **Read Committed**   | ❌ Prevented| ✅ Allowed            | ✅ Allowed     | Only committed data is visible. Default in many databases. |&#10;  | **Repeatable Read**  | ❌ Prevented| ❌ Prevented          | ✅ Allowed     | Rows cannot change, but new rows may appear (phantoms). |&#10;  | **Serializable**     | ❌ Prevented| ❌ Prevented          | ❌ Prevented   | Full isolation, transactions execute as if sequentially. |&#10;&#10;  - **Dirty Read**: Transaction reads data written by another uncommitted transaction.Example: T1 reads a value updated by T2, but T2 hasn't committed. **Solution**: Use `Read Committed` or higher.&#10;  &#10;  - **Non-Repeatable Read**: A row is read twice and returns different data due to an update by another transaction. T1 reads a row, T2 updates and commits it, T1 reads again and gets different data. **Solution**: Use `Repeatable Read` or `Serializable`.&#10;&#10;  - **Phantom Read**: A query returns a different set of rows when re-executed because another transaction inserted/deleted matching rows.Example: T1 runs a query with a condition; T2 inserts a new matching row; T1 reruns and sees new row. **Solution**: Use `Serializable`, or databases supporting MVCC (like PostgreSQL or Oracle).&#10;&#10;- **Durability**: Once a transaction is committed, it remains so, even in the event of a system failure.&#10;### Distributed Transaction Protocols &amp; Patterns&#10;&#10;#### 1. Two-Phase Commit (2PC)&#10;&#10;**Goal:**  &#10;Ensure all participants in a distributed transaction either all commit or all roll back.&#10;&#10;**Roles:**&#10;- **Coordinator** — orchestrates the commit.&#10;- **Participants (Resource Managers)** — e.g., databases, queues.&#10;&#10;**Phases:**&#10;1. **Prepare phase**  &#10;   - Coordinator → Participants: *&quot;Can you commit?&quot;*  &#10;   - Participants:  &#10;     - Validate transaction feasibility (constraints, locks).  &#10;     - If OK → reply **YES** (and lock resources so they can commit later).  &#10;     - If not OK → reply **NO**.&#10;2. **Commit/Abort phase**  &#10;   - If **all YES** → Coordinator sends **COMMIT** to all.  &#10;   - If **any NO** → Coordinator sends **ROLLBACK** to all.&#10;&#10;**Pros:**&#10;- Strong consistency.&#10;- Simple to reason about.&#10;&#10;**Cons:**&#10;- **Blocking** — If coordinator crashes after prepare but before commit, participants wait indefinitely.&#10;- Locks held across prepare → commit can hurt performance.&#10;&#10;---&#10;&#10;#### 2. Three-Phase Commit (3PC)&#10;&#10;**Goal:**  &#10;Reduce 2PC blocking by adding a pre-commit phase.&#10;&#10;**Phases:**&#10;1. **Can Commit**  &#10;   - Same as 2PC’s prepare phase — ask if ready.&#10;2. **Pre-Commit**  &#10;   - If all **YES**: Coordinator sends **PRE-COMMIT** to participants.  &#10;   - Participants acknowledge, enter a state where they can commit without coordinator.&#10;3. **Do Commit**  &#10;   - Coordinator sends **COMMIT**.  &#10;   - If coordinator fails, participants can still commit safely after a timeout (based on pre-commit state).&#10;&#10;**Pros:**&#10;- Less blocking than 2PC.&#10;- Participants can make progress after coordinator failure.&#10;&#10;**Cons:**&#10;- Requires synchronous clocks and reliable network assumptions (rare in real-world WAN).&#10;- More message overhead.&#10;&#10;---&#10;&#10;#### 3. XA Transactions&#10;&#10;**Goal:**  &#10;Provide a standard API for distributed transactions across multiple resource managers.&#10;&#10;**Key Points:**&#10;- Defined by **X/Open XA** spec.&#10;- Involves:&#10;  - **Application** — business logic.&#10;  - **Transaction Manager (TM)** — controls transaction boundaries.&#10;  - **Resource Managers (RM)** — e.g., databases, message brokers.&#10;&#10;**Flow:**&#10;1. Application starts transaction (via TM).&#10;2. Application interacts with multiple RMs.&#10;3. TM calls RMs using XA API to prepare/commit.&#10;4. Under the hood, TM uses **2PC** protocol (almost always).&#10;&#10;**Important:**  &#10;XA is **not** a commit algorithm — it’s a coordination API/spec. But in practice, **XA + 2PC** is the norm.&#10;&#10;#### BASE Properties&#10;BASE stands for Basically Available, Soft state, and Eventually consistent. These properties are common in distributed systems and NoSQL databases:&#10;- **Basically Available**: The system guarantees availability, even in the presence of partial failures.&#10;- **Soft State**: The state of the system may change over time, even without input, due to eventual consistency.&#10;- **Eventually Consistent**: The system will become consistent over time, given that no new updates are made.&#10;&#10;&#10;| Feature                | ACID                                                                                     | BASE                                                                                     |&#10;|------------------------|------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------|&#10;| **Definition**         | Ensures reliable transactions with strong consistency and integrity.                     | Focuses on availability and eventual consistency in distributed systems.                 |&#10;| **Consistency**        | Strong consistency; the database is always in a valid state after a transaction.         | Eventual consistency; the system becomes consistent over time.                          |&#10;| **Availability**       | May sacrifice availability for consistency.                                              | Prioritizes availability, even during partial failures.                                  |&#10;| **Data Integrity**     | High data integrity; suitable for critical applications like banking.                    | Lower data integrity; suitable for scalable systems like social media.                  |&#10;| **Transaction Model**  | Transactions are all-or-nothing (atomic).                                                | Transactions may be partial or eventual.                                                |&#10;| **Use Case**           | Ideal for OLTP systems requiring strict data accuracy.                                   | Ideal for distributed systems requiring high scalability and availability.              |&#10;| **Examples**           | Relational databases like MySQL, PostgreSQL.                                             | NoSQL databases like Cassandra, DynamoDB.                                               |&#10;&#10;---&#10;### Normalization vs Denormalization&#10;&#10;#### Purpose of Normalization&#10;- Organize data to **reduce redundancy** and **improve integrity**.&#10;- Avoid:&#10;  - **Update anomalies**&#10;  - **Insertion anomalies**&#10;  - **Deletion anomalies**&#10;- Achieved by splitting data into well-structured tables and defining relationships.&#10;&#10;---&#10;&#10;#### 1. First Normal Form (1NF)&#10;**Rule:**&#10;- Each column contains **atomic values** (no repeating groups, no arrays).&#10;- Each row-column intersection holds **a single value**.&#10;- Each record must be **unique** (primary key present).&#10;&#10;**Example:**&#10;❌ `Hobbies: [Reading, Swimming]`  &#10;✅  &#10;| ID | Hobby    |&#10;|----|----------|&#10;| 1  | Reading  |&#10;| 1  | Swimming |&#10;&#10;---&#10;&#10;#### 2. Second Normal Form (2NF)&#10;**Prerequisite:** Must be in **1NF**  &#10;**Rule:**&#10;- No **partial dependency** — non-key attributes must depend on the **whole** primary key.&#10;- Applies only to tables with a **composite primary key**.&#10;&#10;**Example:**&#10;❌ `OrderID + ProductID → Quantity`, but `ProductName` depends only on `ProductID`.  &#10;✅ Move product details to a separate **Product** table.&#10;&#10;---&#10;&#10;#### 3. Third Normal Form (3NF)&#10;**Prerequisite:** Must be in **2NF**  &#10;**Rule:**&#10;- No **transitive dependency** — non-key attributes must depend **only** on the primary key.&#10;&#10;**Example:**&#10;❌ `StudentID → DepartmentID → DepartmentName`  &#10;✅ Store `DepartmentID → DepartmentName` in a separate table.&#10;&#10;---&#10;&#10;#### 4. Boyce–Codd Normal Form (BCNF)&#10;**Prerequisite:** Must be in **3NF**  &#10;**Rule:**&#10;- For **every functional dependency (X → Y)**, X must be a **superkey**.&#10;- Stricter than 3NF — resolves anomalies that 3NF may allow.&#10;&#10;---&#10;&#10;#### 5. Fourth Normal Form (4NF)&#10;**Prerequisite:** Must be in **BCNF**  &#10;**Rule:**&#10;- No **multi-valued dependencies** unless they are part of a candidate key.&#10;- Prevents storing unrelated multi-valued facts in the same table.&#10;&#10;**Example:**&#10;If a teacher teaches multiple subjects **and** speaks multiple languages:  &#10;- Store them in separate tables to avoid cross-product redundancy.&#10;&#10;---&#10;&#10;#### 6. Fifth Normal Form (5NF / Project-Join Normal Form)&#10;**Prerequisite:** Must be in **4NF**  &#10;**Rule:**&#10;- No **join dependency** — table should not be reconstructable from smaller tables in any **non-trivial** way.&#10;- Deals with complex relationships broken into **three or more** tables.&#10;&#10;---&#10;&#10;#### Quick Comparison Table&#10;&#10;| Form  | Removes…                 | Focus Area                     |&#10;|-------|--------------------------|---------------------------------|&#10;| 1NF   | Repeating groups, arrays | Atomic data                     |&#10;| 2NF   | Partial dependency       | Full key dependency             |&#10;| 3NF   | Transitive dependency    | Direct PK dependency            |&#10;| BCNF  | Any non-superkey FD      | Strict key dependency           |&#10;| 4NF   | Multi-valued dependency  | No unrelated multi-values       |&#10;| 5NF   | Join dependency          | Complex table reconstruction    |&#10;&#10;&#10;Normalization is the process of organizing data to reduce redundancy and improve data integrity, while denormalization involves combining data to optimize read performance by reducing the number of joins.&#10;&#10;| Feature                | Normalization                                                                 | Denormalization                                                              |&#10;|------------------------|-------------------------------------------------------------------------------|------------------------------------------------------------------------------|&#10;| **Definition**         | Organizing data to reduce redundancy and improve data integrity.             | Combining data to reduce the number of joins and improve read performance.   |&#10;| **Data Redundancy**    | Minimal redundancy; data is stored in separate, related tables.               | Increased redundancy; data is duplicated across tables.                      |&#10;| **Performance**        | Optimized for write operations and data integrity.                            | Optimized for read operations and query performance.                         |&#10;| **Complexity**         | Higher complexity due to multiple tables and relationships.                   | Lower complexity for queries but higher complexity for updates.              |&#10;| **Use Case**           | Suitable for OLTP systems where data integrity and consistency are critical.  | Suitable for OLAP systems where fast read performance is required.           |&#10;| **Storage**            | Requires less storage due to reduced redundancy.                              | Requires more storage due to duplicated data.                                |&#10;| **Maintenance**        | Easier to maintain data integrity and consistency.                            | Harder to maintain consistency due to data duplication.                      |&#10;&#10;---&#10;### CAP Theorem&#10;&#10;The **CAP Theorem**—also known as **Brewer’s Theorem**—states that in any distributed data system, it is **impossible to simultaneously guarantee** all three of the following properties:&#10;&#10;- **C** — **Consistency** - Every read receives the most recent write or an error. Equivalent to strong consistency across nodes.&#10;- **A** — **Availability** - Every request (read or write) receives a non-error response, without the guarantee that it contains the most recent write. The system is responsive even under stress.&#10;- **P** — **Partition Tolerance** - The system continues to operate despite arbitrary partitioning (network failures/loss of connectivity between nodes). Must handle message loss or delay. In any real-world distributed system. So the real choice is between **Consistency** and **Availability**.&#10;&#10;&#10;In practice, a system can **only guarantee two out of the three** at any given time. However with some complimenting strategies you can close to achieve the best of all for a given usecase. Remember the strongly and eventually consistant modes in case of Dynamodb.&#10;&#10;#### Design Trade-offs: Choosing Two&#10;&#10;| Type       | Properties Chosen | Trade-off |&#10;|------------|-------------------|-----------|&#10;| **CP**     | Consistency + Partition Tolerance | May reject requests during partition to preserve data integrity. |&#10;| **CA**     | Consistency + Availability | Not realistic in distributed systems since network partitions are unavoidable. |&#10;| **AP**     | Availability + Partition Tolerance | System may serve stale data or become eventually consistent. |&#10;&#10;#### Design Perspective: What to Choose?&#10;&#10;| Use Case | Recommended Trade-off | Reason |&#10;|----------|------------------------|--------|&#10;| **Banking/Financial Systems** | **CP** | Strong consistency is critical for correctness. |&#10;| **Social Media Feeds**        | **AP** | Availability is prioritized; slight staleness is acceptable. |&#10;| **E-commerce Carts**          | **AP** or **CP** | Depends on whether consistency (inventory) or uptime is more important. |&#10;| **Real-time Messaging**       | **AP** | Users expect availability; some eventual consistency is acceptable. |&#10;&#10;![](../cap.png)&#10;&#10;&gt; ⚠️ **Note**: CAP is a simplified model. In practice, systems also consider latency, throughput, durability, and more advanced consistency models like **Causal Consistency**, **Eventual Consistency**, and **Linearizability**.&#10;&#10;#### Linearizability (Strong Consistency)&#10;- Guarantees that all **operations appear to happen atomically and in a single, global order**.&#10;- Once a write completes, all subsequent reads must return that value or a newer one.&#10;- Operations appear **instantaneous** from the perspective of all clients.&#10;&#10;**Example**:&#10;- User A transfers $100 from Account X to Y.&#10;- User B queries Account X and sees the debited balance immediately.&#10;- No matter which server or region the users connect to, the order is preserved.&#10;&#10;**Pros**:&#10;- Predictable and intuitive behavior.&#10;- Ideal for critical systems (e.g., banking, ledgers).&#10;&#10;**Cons**:&#10;- Slower performance due to coordination overhead.&#10;- Difficult to scale globally.&#10;&#10;#### Causal Consistency (Eventual Consistency)&#10;- Guarantees that **causally related operations are seen in the same order by all nodes**.&#10;- Independent operations may be seen in different orders by different nodes.&#10;&#10;**Example**:&#10;- Alice posts: &quot;I love this product!&quot;&#10;- Bob replies: &quot;Me too!&quot;&#10;- Everyone should see Alice’s post **before** Bob’s reply — because the reply is causally dependent.&#10;&#10;**Pros**:&#10;- Faster and more scalable.&#10;- Sufficient for collaborative apps, chat, social networks.&#10;&#10;**Cons**:&#10;- Weaker guarantee: simultaneous updates may appear in different orders to different users.&#10;- Not suitable for systems needing strong accuracy guarantees.&#10;&#10;---&#10;&#10;### Blob Storage&#10;---&#10;## Scalability and Performance&#10;### Vertical and Horizontal Scaling&#10;&#10;Scaling is a critical aspect of system design that ensures a system can handle increased load or demand. There are two primary types of scaling: vertical scaling and horizontal scaling.&#10;Increase the power of a single machine.&#10;&#10;- **Methods:** Add CPU, RAM, faster storage, GPUs, etc.&#10;- **Pros:**&#10;  - Simple to implement&#10;  - Often no code change required&#10;- **Cons:**&#10;  - Hardware limits&#10;  - Expensive&#10;  - Single point of failure remains&#10;- **Example:** Upgrading a database server from 8 cores to 64 cores&#10;&#10;#### Vertical Scaling&#10;Vertical scaling, also known as &quot;scaling up,&quot; involves adding more resources (e.g., CPU, RAM, or storage) to a single machine. This approach is straightforward and often requires minimal changes to the application.&#10;&#10;**Advantages:**&#10;- Simplicity: Easier to implement and manage e.g. Postgres RDBMS Scaling up and down.&#10;- No need for distributed systems: Avoids complexities like data partitioning and synchronization.&#10;- Suitable for monolithic applications.&#10;&#10;**Disadvantages:**&#10;- Hardware limitations: There is a physical limit to how much a single machine can be upgraded.&#10;- Single point of failure: If the machine fails, the entire system goes down.&#10;- Cost: High-end hardware can be expensive.&#10;&#10;#### Horizontal Scaling&#10;Horizontal scaling, or &quot;scaling out,&quot; involves adding more machines to distribute the load. This approach is commonly used in distributed systems and cloud environments.&#10;&#10;**Advantages:**&#10;- Scalability: Can handle virtually unlimited growth by adding more machines.&#10;- Fault tolerance: Reduces the risk of a single point of failure.&#10;- Cost efficiency: Commodity hardware can be used instead of expensive high-end machines.&#10;&#10;**Disadvantages:**&#10;- Complexity: Requires distributed systems, load balancing, and data partitioning.&#10;- Consistency challenges: Ensuring data consistency across multiple nodes can be difficult.&#10;- Network overhead: Communication between nodes can introduce latency.&#10;&#10;#### Choosing Between Vertical and Horizontal Scaling&#10;- **When to use vertical scaling:**&#10;  - When the application is monolithic and not designed for distributed systems.&#10;  - When the load is predictable and within the limits of a single machine.&#10;  - When simplicity and quick implementation are priorities.&#10;&#10;- **When to use horizontal scaling:**&#10;  - When the system needs to handle unpredictable or massive growth.&#10;  - When fault tolerance and high availability are critical.&#10;  - When the application is designed as a distributed system.&#10;  - Easy in Cloud infrastructure - Pay per use or Pay as you go.&#10;&#10;#### Combining Vertical and Horizontal Scaling&#10;In practice, systems often use a combination of vertical and horizontal scaling. For example:&#10;- Start with vertical scaling for simplicity and quick deployment.&#10;- Transition to horizontal scaling as the system grows and requires higher availability.&#10;&#10;By understanding the trade-offs and leveraging efficient algorithms, you can design systems that scale effectively to meet user demands.&#10;&#10;### Vertical vs Horizontal Scaling&#10;&#10;Vertical scaling and horizontal scaling are two approaches to handle increased system load. Here's a comparison:&#10;&#10;| Feature                | Vertical Scaling                                                              | Horizontal Scaling                                                             |&#10;|------------------------|-------------------------------------------------------------------------------|------------------------------------------------------------------------------|&#10;| **Definition**         | Adding more resources (CPU, RAM, etc.) to a single machine.                  | Adding more machines to distribute the load.                                 |&#10;| **Scalability**        | Limited by the hardware capacity of a single machine.                        | Virtually unlimited by adding more machines.                                 |&#10;| **Fault Tolerance**    | Single point of failure; if the machine fails, the system goes down.         | Higher fault tolerance; failure of one machine does not affect the system.   |&#10;| **Complexity**         | Simpler to implement and manage.                                             | Requires distributed systems, load balancing, and data partitioning.         |&#10;| **Cost**               | High cost for high-end hardware.                                             | Cost-effective with commodity hardware.                                      |&#10;| **Use Case**           | Suitable for monolithic applications with predictable loads.                 | Suitable for distributed systems with unpredictable or massive growth.       |&#10;&#10;### Algorithmic Scaling&#10;&#10;Algorithmic scaling plays a crucial role in ensuring that systems can handle increased load efficiently. By leveraging efficient algorithms and data structures, you can optimize performance and scalability, often reducing the need for additional hardware or resources.&#10;![](../algoscaling.png)&#10;&#10;**Big O Notation:**&#10;Big O notation is used to describe the efficiency of an algorithm in terms of time and space complexity. Common complexities include:&#10;- **O(1):** Constant time. Example: Hash table lookups.&#10;- **O(log n):** Logarithmic time. Example: Binary search.&#10;- **O(n):** Linear time. Example: Iterating through a list.&#10;- **O(n log n):** Log-linear time. Example: Merge sort.&#10;- **O(n^2):** Quadratic time. Example: Nested loops.&#10;&#10;## 2️⃣ Distributed Scaling — The Scale Cube&#10;(*You already know these, so just the headings for completeness*)&#10;&#10;- **X-axis:** Horizontal duplication&#10;- **Y-axis:** Functional decomposition&#10;- **Z-axis:** Data partitioning&#10;&#10;---&#10;&#10;## 3️⃣ Additional Scaling Techniques (Beyond the Cube)&#10;&#10;### 3.1 Scaling by Caching&#10;Reduce load by storing frequently accessed results.  &#10;**Examples:** CDN, Redis, in-memory caches&#10;&#10;### 3.2 Scaling by Asynchrony &amp; Queues&#10;Smooth out load spikes by processing tasks asynchronously.  &#10;**Examples:** Message brokers, event-driven architecture&#10;&#10;### 3.3 Scaling by Algorithmic Efficiency&#10;Reduce the amount of work or make it faster.  &#10;**Examples:** Better data structures, batching, indexing&#10;&#10;### 3.4 Scaling by Concurrency Model&#10;Handle more work in parallel.  &#10;**Examples:** Async I/O, multi-threading, actor model&#10;&#10;### 3.5 Scaling Geographically&#10;Deploy systems in multiple regions for latency and failover benefits.  &#10;**Examples:** Multi-region deployments, edge computing&#10;&#10;---&#10;&#10;## Layered View&#10;&#10;1. **First Layer** → Vertical scaling (make one box stronger)&#10;2. **Second Layer** → Scale Cube (X, Y, Z axes for distribution)&#10;3. **Third Layer** → Optimizations (caching, async, efficiency, concurrency, geo-distribution)&#10;&#10;### Examples of Big O Notation in Java&#10;&#10;#### O(1) - Constant Time&#10;```java&#10;public int getFirstElement(int[] array) {&#10;    return array[0]; // Accessing the first element is constant time.&#10;}&#10;```&#10;&#10;#### O(log n) - Logarithmic Time&#10;```java&#10;public int binarySearch(int[] array, int target) {&#10;    int left = 0, right = array.length - 1;&#10;    while (left &lt;= right) {&#10;        int mid = left + (right - left) / 2;&#10;        if (array[mid] == target) {&#10;            return mid; // Found the target.&#10;        } else if (array[mid] &lt; target) {&#10;            left = mid + 1; // Search in the right half.&#10;        } else {&#10;            right = mid - 1; // Search in the left half.&#10;        }&#10;    }&#10;    return -1; // Target not found.&#10;}&#10;```&#10;&#10;#### O(n) - Linear Time&#10;```java&#10;public int findMax(int[] array) {&#10;    int max = array[0];&#10;    for (int num : array) {&#10;        if (num &gt; max) {&#10;            max = num; // Update max if a larger number is found.&#10;        }&#10;    }&#10;    return max;&#10;}&#10;```&#10;&#10;#### O(n log n) - Log-Linear Time&#10;```java&#10;import java.util.Arrays;&#10;&#10;public void sortArray(int[] array) {&#10;    Arrays.sort(array); // Sorting an array using a comparison-based algorithm like Merge Sort.&#10;}&#10;```&#10;&#10;#### O(n^2) - Quadratic Time&#10;```java&#10;public void printAllPairs(int[] array) {&#10;    for (int i = 0; i &lt; array.length; i++) {&#10;        for (int j = 0; j &lt; array.length; j++) {&#10;            System.out.println(array[i] + &quot;, &quot; + array[j]); // Print all pairs.&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;#### O(2^n) - Exponential Time&#10;```java&#10;public int fibonacci(int n) {&#10;    if (n &lt;= 1) {&#10;        return n; // Base case.&#10;    }&#10;    return fibonacci(n - 1) + fibonacci(n - 2); // Recursive calls.&#10;}&#10;```&#10;&#10;#### O(n!) - Factorial Time&#10;```java&#10;public void generatePermutations(String str, String perm) {&#10;    if (str.isEmpty()) {&#10;        System.out.println(perm); // Print a permutation.&#10;        return;&#10;    }&#10;    for (int i = 0; i &lt; str.length(); i++) {&#10;        char ch = str.charAt(i);&#10;        String remaining = str.substring(0, i) + str.substring(i + 1);&#10;        generatePermutations(remaining, perm + ch); // Recursive call.&#10;    }&#10;}&#10;```&#10;&#10;### Load Balancers&#10;### Rate Limiting&#10;### Content Delivery Optimization&#10;### Zero Downtime Deployment&#10;---&#10;## Common Design Patterns and Architecture&#10;### Event-Driven Architecture&#10;### Data Partitioning Strategies&#10;### Eventual Consistency&#10;### Leader Election&#10;### Circuit Breaker Pattern&#10;### Throttling and Backpressure&#10;### Service Discovery&#10;### Microservices&#10;### Message Queues&#10;---&#10;## Monitoring, Resiliency, and Security&#10;### Monitoring and Observability&#10;### Data Compression&#10;### Authentication and Authorization&#10;### Data Backup and Recovery&#10;### Chaos Engineering&#10;---&#10;## Development and Deployment&#10;### Concurrency Control&#10;### Immutable Infrastructure&#10;### Blue-Green Deployment&#10;---&#10;## Theoretical Concepts&#10;### Search Systems&#10;---&#10;## Data Processing&#10;### Data Streaming&#10;---&#10;## Miscellaneous&#10;### Rate Shaping&#10;---&#10;## Laws&#10;### General Engineering &amp; Design Principles&#10;* Murphy’s Law – “Anything that can go wrong will go wrong.” → Build for resilience and failure recovery.&#10;&#10;* Gall’s Law – Complex systems that work evolve from simple systems that work.&#10;&#10;* Occam’s Razor – Prefer the simplest solution that meets the requirements.&#10;&#10;* KISS Principle – “Keep It Simple, Stupid.” Avoid unnecessary complexity.&#10;&#10;* YAGNI – “You Aren’t Gonna Need It.” Don’t implement features until they are actually needed.&#10;&#10;* DRY Principle – “Don’t Repeat Yourself.” Centralize logic to avoid duplication.&#10;&#10;* Robustness Principle (Postel’s Law) – Be conservative in what you send, liberal in what you accept.&#10;&#10;### Time, Effort, and Estimation&#10;* Hofstadter’s Law – “It always takes longer than you expect, even when you take into account Hofstadter’s Law.”&#10;&#10;* Parkinson’s Law – “Work expands to fill the time available for its completion.”&#10;&#10;* Brooks’s Law – “Adding manpower to a late software project makes it later.” (From The Mythical Man-Month)&#10;&#10;* Ninety-Ninety Rule – The first 90% of the code accounts for the first 90% of the development time; the remaining 10% of the code accounts for the other 90% of the development time.&#10;&#10;* Pareto Principle (80/20 Rule) – 80% of the effects come from 20% of the causes; focus on the critical 20%.&#10;&#10;### People, Teams, and Communication&#10;* Conway’s Law – System design mirrors the communication structure of the organization.&#10;&#10;* Peter Principle – People rise to their level of incompetence.&#10;&#10;* Linus’s Law – “Given enough eyeballs, all bugs are shallow.” (Open-source development insight)&#10;&#10;* Law of Triviality (Parkinson’s Law of Triviality) – People spend disproportionate time on trivial issues (bike-shedding).&#10;&#10;### Code Quality &amp; Maintainability&#10;* Law of Demeter – Talk only to your immediate collaborators; avoid unnecessary coupling.&#10;&#10;* Boyle’s Law of Code – Code will expand to fill all available complexity.&#10;&#10;* Hyrum’s Law – With enough users, all observable behaviors of your system will be relied upon, intentional or not.&#10;&#10;* LeBlanc’s Law – “Later equals never.” If you say you’ll fix it later, you probably won’t.&#10;&#10;* Zawinski’s Law – Every program attempts to expand until it can read mail; those that cannot are replaced by ones that can.&#10;&#10;### Reliability &amp; Risk&#10;* Finagle’s Law – Anything that can go wrong, will—at the worst possible time.&#10;&#10;* Sod’s Law – Similar to Murphy’s Law, but with more emphasis on timing and bad luck.&#10;&#10;* Schneier’s Law – Anyone can create an encryption algorithm they themselves cannot break; that doesn’t mean it’s secure.&#10;&#10;&#10;" />
              <option name="updatedContent" value="+++&#10;date = '2025-05-03T12:44:47+10:00'&#10;draft = false&#10;title = 'System Design Interview Concepts'&#10;tags = ['Event Driven Architecture', 'Microservices', 'Interview']&#10;+++&#10;&#10;System design is a critical aspect of software engineering that involves creating scalable, reliable, and efficient systems. This document explores key concepts and strategies required for designing robust systems, including networking, databases, scalability, caching, and modern architectural patterns. It serves as a comprehensive guide for understanding the foundational and advanced principles of system design.&#10;&#10;## Table of Contents&#10;&#10;- [Approach](#approach)&#10;- [HTTPS Certificates in System Design](#https-certificates-in-system-design)&#10;- [Key Points about HTTPS Certificates](#key-points-about-https-certificates)&#10;- [HTTPS Flow in System Design](#https-flow-in-system-design)&#10;- [HTTPS Certificate Components](#https-certificate-components)&#10;- [Use Cases in System Design](#use-cases-in-system-design)&#10;- [Design Considerations for HTTPS Certificates](#design-considerations-for-https-certificates)&#10;- [Key Takeaways for System Design](#key-takeaways-for-system-design)&#10;- [Networking and Communication](#networking-and-communication)&#10;  - [Client Server Architecture](#client-server-architecture)&#10;  - [IP Address](#ip-address)&#10;  - [DNS](#dns)&#10;  - [Proxy/Reverse Proxy](#proxyreverse-proxy)&#10;  - [Latency](#latency)&#10;  - [HTTP/HTTPS and MASL (Mutual Authentication Security Layers)](#httphttps-and-masl-mutual-authentication-security-layers)&#10;    - [HTTP / HTTPS in System Design](#1-http--https-in-system-design)&#10;    - [Details of handshake](#details-of-handshake)&#10;    - [Summary of Key Components](#summary-of-key-components)&#10;    - [Mutual Authentication (mTLS)](#what-is-mutual-authentication-mtls)&#10;    - [Details of handshake (mTLS)](#details-of-handshake-1)&#10;  - [WebSockets](#websockets)&#10;  - [Webhooks](#webhooks)&#10;- [APIs and Integration](#apis-and-integration)&#10;  - [APIs](#apis)&#10;  - [REST API](#rest-api)&#10;  - [GraphQL](#graphql)&#10;  - [API Gateway](#api-gateway)&#10;  - [Idempotency](#idempotency)&#10;  - [REST and REST Maturity Model](#rest-and-rest-maturity-model)&#10;- [Databases and Storage](#databases-and-storage)&#10;  - [Databases](#databases)&#10;  - [SQL vs NoSQL vs Object Store](#sql-vs-nosql-vs-object-store)&#10;  - [Database Indexing](#database-indexing)&#10;  - [Replication](#replication)&#10;  - [Sharding](#sharding)&#10;  - [Vertical Partitioning](#vertical-partitioning)&#10;  - [Caching](#caching)&#10;  - [ACID vs BASE](#acid-vs-base)&#10;  - [Normalization vs Denormalization](#normalization-vs-denormalization)&#10;  - [CAP Theorem](#cap-theorem)&#10;  - [Blob Storage](#blob-storage)&#10;- [Scalability and Performance](#scalability-and-performance)&#10;  - [Vertical and Horizontal Scaling](#vertical-and-horizontal-scaling)&#10;  - [Algorithmic Scaling](#algorithmic-scaling)&#10;  - [The Scale Cube](#2️⃣-distributed-scaling--the-scale-cube)&#10;  - [Additional Scaling Techniques](#3️⃣-additional-scaling-techniques-beyond-the-cube)&#10;  - [Layered View](#layered-view)&#10;  - [Examples of Big O Notation in Java](#examples-of-big-o-notation-in-java)&#10;  - [Load Balancers](#load-balancers)&#10;  - [Rate Limiting](#rate-limiting)&#10;  - [Content Delivery Optimization](#content-delivery-optimization)&#10;  - [Zero Downtime Deployment](#zero-downtime-deployment)&#10;- [Common Design Patterns and Architecture](#common-design-patterns-and-architecture)&#10;  - [Event-Driven Architecture](#event-driven-architecture)&#10;  - [Data Partitioning Strategies](#data-partitioning-strategies)&#10;  - [Eventual Consistency](#eventual-consistency)&#10;  - [Leader Election](#leader-election)&#10;  - [Circuit Breaker Pattern](#circuit-breaker-pattern)&#10;  - [Throttling and Backpressure](#throttling-and-backpressure)&#10;  - [Service Discovery](#service-discovery)&#10;  - [Microservices](#microservices)&#10;  - [Message Queues](#message-queues)&#10;- [Monitoring, Resiliency, and Security](#monitoring-resiliency-and-security)&#10;  - [Monitoring and Observability](#monitoring-and-observability)&#10;  - [Data Compression](#data-compression)&#10;  - [Authentication and Authorization](#authentication-and-authorization)&#10;  - [Data Backup and Recovery](#data-backup-and-recovery)&#10;  - [Chaos Engineering](#chaos-engineering)&#10;- [Development and Deployment](#development-and-deployment)&#10;  - [Concurrency Control](#concurrency-control)&#10;  - [Immutable Infrastructure](#immutable-infrastructure)&#10;  - [Blue-Green Deployment](#blue-green-deployment)&#10;- [Theoretical Concepts](#theoretical-concepts)&#10;  - [Search Systems](#search-systems)&#10;- [Data Processing](#data-processing)&#10;  - [Data Streaming](#data-streaming)&#10;- [Miscellaneous](#miscellaneous)&#10;  - [Rate Shaping](#rate-shaping)&#10;- [Laws](#laws)&#10;  - [General Engineering &amp; Design Principles](#general-engineering--design-principles)&#10;  - [Time, Effort, and Estimation](#time-effort-and-estimation)&#10;  - [People, Teams, and Communication](#people-teams-and-communication)&#10;  - [Code Quality &amp; Maintainability](#code-quality--maintainability)&#10;  - [Reliability &amp; Risk](#reliability--risk)&#10;&#10;## Approach&#10;- Do not directly start designing; every problem is unique. Think of every problem as designing and building a bridge. You must understand:&#10;  - **Whom or What you are building for**  &#10;    - target users or audience and their count.  &#10;    - Expected traffic or load  &#10;    - User behavior e.g. Celebrity Problem &#10;    - Interaction patterns.  &#10;    - Account for user demographics and geographic distribution.  &#10;    - Evaluate the specific needs or goals of the users.&#10;  - **Where you are building** (the environment or constraints).&#10;  - **How you build**.&#10;&#10;## Steps:&#10;- **Understand your use case**: Clearly define the problem and its requirements.&#10;- **Ask the right questions**: Gather Necessary details, NO assumptions.&#10;- **Decide the modules**: Break the big problem into smaller, manageable parts (e.g., defining context boundaries). Ask which they want you to tackle first.&#10;- **Design with key considerations**:  Address other critical &quot;ilities&quot;&#10;     - **Availability**&#10;     - **Reliability**&#10;     - **Maintainability**&#10;     - **Performance**&#10;     - **Scalability**&#10;     - **Cost-efficiency**&#10;     - **Security**&#10;     - **Flexibility**&#10;     (Always remind yourself - everything fails)&#10;---&#10;## HTTPS Certificates in System Design&#10;&#10;In system design, **HTTPS certificates** are essential for securing communication between clients (e.g., web browsers, mobile apps) and servers. They are used to encrypt data, verify server identity, and ensure secure communication channels in modern web and microservice architectures.&#10;&#10;---&#10;&#10;## Key Points about HTTPS Certificates&#10;&#10;### 1. **What is an HTTPS Certificate?**&#10;- **HTTPS certificates** are **X.509 certificates** used in **TLS (Transport Layer Security)** for encrypting and securing HTTP traffic.&#10;- They contain the **public key** of a server, and are signed by a trusted **Certificate Authority (CA)** to confirm the authenticity of the server.&#10;&#10;### 2. **Role in HTTPS Communication:**&#10;- **Encryption**: HTTPS certificates use **TLS** to encrypt data in transit, ensuring that information exchanged between client and server is private and secure.&#10;- **Authentication**: The certificate proves the server's identity, assuring clients that they are communicating with the correct, trusted server.&#10;- **Data Integrity**: It ensures that data cannot be tampered with while in transit.&#10;&#10;---&#10;&#10;## HTTPS Flow in System Design&#10;&#10;1. **DNS Resolution** → The domain name (e.g., `example.com`) is resolved to an IP address.&#10;2. **TCP Handshake** → A 3-way handshake is established between the client and server.&#10;3. **TLS Handshake**:&#10;   - The client requests a secure connection and receives the server's certificate.&#10;   - The client verifies the certificate's authenticity (checking the CA and validity period).&#10;   - The client and server exchange keys to encrypt further communication.&#10;4. **Secure Communication**: The HTTP request and response occur over the encrypted TLS channel.&#10;5. **Connection Termination**: Once communication is complete, the connection is securely closed.&#10;&#10;---&#10;&#10;## HTTPS Certificate Components&#10;&#10;1. **Public Key**: Used for encryption and establishing a secure connection.&#10;2. **Issuer**: The Certificate Authority (CA) that issued the certificate.&#10;3. **Subject**: The entity (e.g., website, server) being identified by the certificate.&#10;4. **Validity Period**: The certificate’s expiration date.&#10;5. **Signature**: A digital signature from the CA, ensuring the certificate's authenticity.&#10;6. **Extensions**: Additional metadata, such as **Subject Alternative Names (SANs)**, which allow a single certificate to cover multiple domains.&#10;&#10;---&#10;&#10;## Use Cases in System Design&#10;&#10;### 1. **Web Applications**&#10;- HTTPS certificates are used to secure user data, such as login credentials and payment details, during transmission between the browser and server.&#10;- **SSL/TLS** ensures that users can trust the site and prevents **man-in-the-middle attacks**.&#10;&#10;### 2. **API Security**&#10;- APIs use HTTPS certificates to secure communication between clients and services, ensuring that data transmitted between services is encrypted and authenticated.&#10;- **API Gateways** often enforce HTTPS for all incoming and outgoing traffic to secure internal and external communications.&#10;&#10;### 3. **Microservices Communication**&#10;- In microservices architectures, services communicate securely using **TLS** certificates.&#10;- Certificates can be used with **mTLS (Mutual TLS)**, where both the client and the server authenticate each other.&#10;- This is common for ensuring trust between services within a **private network**.&#10;&#10;### 4. **Certificate Pinning**&#10;- To prevent attacks, some systems implement **certificate pinning** to ensure that only a specific, trusted certificate can be used, even if it’s issued by a trusted CA.&#10;&#10;---&#10;&#10;## Design Considerations for HTTPS Certificates&#10;&#10;### 1. **Certificate Management:**&#10;   - **Renewal**: Certificates must be renewed periodically (typically every 1-2 years).&#10;   - **Revocation**: Certificates must be revoked if compromised, and Certificate Revocation Lists (CRLs) or **OCSP (Online Certificate Status Protocol)** can be used to check the certificate status.&#10;&#10;### 2. **Load Balancers and API Gateways:**&#10;   - **SSL Termination**: In many architectures, HTTPS connections are terminated at a **load balancer** or **API Gateway**. This means the secure connection between the client and the gateway is decrypted, and the communication between services may continue over plain HTTP or encrypted further.&#10;&#10;### 3. **Security Best Practices:**&#10;   - Use strong encryption algorithms (e.g., **TLS 1.2 or 1.3**).&#10;   - **Perfect Forward Secrecy (PFS)** should be enabled to ensure that past sessions are not compromised even if the server's private key is leaked.&#10;   - Regularly update certificates and private keys.&#10;   - Store private keys securely and limit access.&#10;&#10;---&#10;&#10;## Key Takeaways for System Design&#10;&#10;- **HTTPS certificates** are crucial for securing **web traffic** and **API communications** in modern system architectures.&#10;- They ensure **confidentiality**, **integrity**, and **authentication** between clients and servers.&#10;- Proper **certificate management** (renewal, revocation, etc.) is key for maintaining security.&#10;- **SSL/TLS termination** at **API Gateways** or **load balancers** can simplify management but must be carefully designed to ensure traffic is encrypted when needed.&#10;- **mTLS** can be used for mutual authentication between services, adding an additional layer of security in microservices architectures.&#10;&#10;&#10;## Networking and Communication&#10;### Client Server Architecture&#10;### IP Address&#10;### DNS&#10;### Proxy/Reverse Proxy&#10;### Latency&#10;### HTTP/HTTPS and MASL (Mutual Authentication Security Layers)&#10;&#10;##  1. HTTP / HTTPS in System Design&#10;&#10;###  HTTP&#10;- Stateless protocol for transferring hypertext and media between client and server.&#10;- Operates over **TCP** (usually port **80**).&#10;- Requests consist of **methods** (GET, POST, PUT, DELETE), **headers**, and optionally a **body**.&#10;- No built-in encryption → data sent in plaintext.&#10;&#10;###  HTTPS&#10;- HTTP over **TLS (Transport Layer Security)** → operates on port **443**.&#10;&#10;**Provides:**&#10;-  **Confidentiality:** Encrypts data.&#10;- ️ **Integrity:** Detects tampering.&#10;-  **Authentication:** Validates server identity via SSL/TLS certificates.&#10;&#10;**Used In:**&#10;- Web apps  &#10;- REST APIs  &#10;- Microservices communication  &#10;- IoT and mobile devices  &#10;&#10;##  Details of handshake &#10;&lt;img width=&quot;3000&quot; height=&quot;3336&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/2e8bf550-4932-4c84-a2ca-b3034b57c1f8&quot; /&gt;&#10;&#10;### 1. Client Hello&#10;The client initiates the handshake by sending:&#10;- A list of supported **cipher suites** (algorithms for encryption, key exchange, etc.).&#10;- A **`client_random`** value — a 32-byte random number.&#10;&#10;####  Why `client_random`?&#10;- Adds **entropy** to the key derivation process.&#10;- Ensures each session is **unique**, even if the same algorithms are used.&#10;- Helps prevent **replay attacks** by making the handshake unpredictable.&#10;&#10;### 2. Server Hello + Certificate&#10;The server responds with:&#10;- A selected **cipher suite** from the client's list.&#10;- Its own **`server_random`** value.&#10;- A **digital certificate** (usually X.509) containing its public key and identity.&#10;&#10;####  Why the Certificate?&#10;- Allows the client to **authenticate** the server.&#10;- The client checks:&#10;  - Is the certificate signed by a trusted Certificate Authority (CA)?&#10;  - Is it still valid (not expired)?&#10;  - Does the domain match?&#10;&#10;### 3. Key Exchange and Session Key Derivation&#10;Depending on the chosen cipher suite (e.g., ECDHE), the client and server:&#10;- Exchange **ephemeral public keys**.&#10;- Each side uses its private key and the other’s public key to compute a **shared secret**.&#10;- They use a **Key Derivation Function (KDF)** to combine:&#10;  - The shared secret&#10;  - `client_random`&#10;  - `server_random`&#10;  → to derive **symmetric session keys**.&#10;####  How the Shared Secret Is Computed in ECDHE&#10;&#10; Key Generation&#10;**Client generates:**&#10;&#10;- Private key: a&#10;- Public key: A = aG&#10;**Server generates:**&#10;&#10;- Private key: b&#10;- Public key: B = bG&#10;Here, G is a known base point on the elliptic curve.&#10;- **Client computes**:  &#10;  `S = a * B = a * (bG) = abG`&#10;- **Server computes**:  &#10;  `S = b * A = b * (aG) = abG`&#10;✅ Both arrive at the **same shared secret** `S = abG`.&#10;&#10;####  Why Ephemeral Keys (ECDHE)?&#10;- Provides **forward secrecy**: even if long-term keys are compromised, past sessions remain secure.&#10;- Ensures that each session has **unique encryption keys**.&#10;&#10;### 4. Finished Messages&#10;- Both sides send encrypted &quot;Finished&quot; messages to confirm that the handshake was successful.&#10;- From this point on, all communication is encrypted using the derived session keys.&#10;&#10;---&#10;&#10;###  Summary of Key Components&#10;&#10;| Component        | Purpose                                      |&#10;|------------------|----------------------------------------------|&#10;| `client_random`  | Adds entropy, uniqueness, and prevents replay attacks |&#10;| `server_random`  | Same as above, from the server side          |&#10;| Certificate      | Authenticates the server (and optionally the client) |&#10;| Ephemeral Keys   | Used to compute a shared secret securely     |&#10;| Session Keys     | Encrypt and authenticate all further communication |&#10;&#10;&#10;---&#10;&#10;##  What is Mutual Authentication (mTLS)?&#10;&#10;###  Common Use Cases&#10;&#10;| Use Case                      | Why Use mTLS?                                     |&#10;|------------------------------|---------------------------------------------------|&#10;| Service-to-service (microservices) | Ensure only trusted services communicate          |&#10;| APIs for fintech / healthcare | Regulatory compliance (HIPAA, PCI-DSS)            |&#10;| IoT Devices ↔ Cloud          | Authenticate individual devices securely          |&#10;| Enterprise internal apps     | Add trust within a private/internal network       |&#10;&#10;##  Details of handshake &#10;&lt;img width=&quot;1452&quot; height=&quot;2322&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/93556c5e-3e0b-42a2-90e0-aae7c0ad1da6&quot; /&gt;&#10;&#10;### 1. Client Hello&#10;- Client sends supported cipher suites and `client_random`.&#10;&#10;### 2. Server Hello + Certificate&#10;- Server responds with:&#10;  - Chosen cipher suite&#10;  - `server_random`&#10;  - Server certificate&#10;&#10;### 3. Server Requests Client Certificate&#10;- Server sends a `CertificateRequest` message.&#10;&#10;### 4. Client Sends Certificate&#10;- Client sends its certificate for authentication.&#10;&#10;### 5. Key Exchange&#10;- Both sides exchange ephemeral public keys (e.g., via ECDHE).&#10;- Each side computes the shared secret using its private key and the other’s public key.&#10;&#10;### 6. Certificate Verification&#10;- Server verifies the client’s certificate.&#10;- Client verifies the server’s certificate.&#10;&#10;### 7. Finished Messages&#10;- Both sides send encrypted &quot;Finished&quot; messages.&#10;- Secure communication begins using derived session keys.&#10;&#10;&#10;&#10;### WebSockets&#10;---&#10;### Webhooks&#10;---&#10;## APIs and Integration&#10;### APIs&#10;---&#10;### REST API&#10;---&#10;### GraphQL&#10;---&#10;### API Gateway&#10;---&#10;### Idempotency&#10;&#10;## REST and REST Maturity Model&#10;### What is REST?&#10;REST (Representational State Transfer) is an architectural style for designing networked applications. It relies on stateless communication and standard HTTP methods to enable interaction between clients and servers. RESTful APIs are widely used for their simplicity, scalability, and compatibility with web standards.&#10;&#10;Key principles of REST include:&#10;- **Statelessness**: Each request from a client to a server must contain all the information needed to understand and process the request.&#10;- **Client-Server Architecture**: Separation of concerns between the client and server, allowing them to evolve independently.&#10;- **Uniform Interface**: A consistent and standardized way of interacting with resources.&#10;- **Resource-Based**: Resources are identified using URIs (Uniform Resource Identifiers).&#10;- **Cacheability**: Responses must define whether they are cacheable to improve performance.&#10;- **Layered System**: The architecture can have multiple layers, such as load balancers and proxies, to improve scalability and security.&#10;&#10;### REST Maturity Model&#10;The REST Maturity Model, introduced by Leonard Richardson, defines levels of maturity for RESTful APIs. It helps evaluate how closely an API adheres to REST principles.&#10;&#10;![](../REST.png)&#10;&#10;#### Level 0: The Swamp of POX&#10;- APIs at this level use a single URI and rely on HTTP POST for all interactions.&#10;- They often resemble RPC (Remote Procedure Call) or SOAP (Simple Object Access Protocol).&#10;&#10;#### Level 1: Resources&#10;- Introduces the concept of resources, each identified by a unique URI.&#10;- HTTP methods are not yet fully utilized.&#10;&#10;#### Level 2: HTTP Verbs&#10;- Uses standard HTTP methods (GET, POST, PUT, DELETE, etc.) to perform operations on resources.&#10;- Improves clarity and aligns with REST principles.&#10;&#10;#### Level 3: Hypermedia Controls (HATEOAS)&#10;- Hypermedia as the Engine of Application State (HATEOAS) is implemented.&#10;- Clients can navigate the API dynamically using links provided in responses.&#10;- This level achieves full REST maturity by enabling discoverability and self-documentation.&#10;&#10;### Benefits of REST Maturity&#10;- **Scalability**: Higher levels of maturity improve scalability by leveraging HTTP standards.&#10;- **Interoperability**: Adherence to REST principles ensures compatibility across different platforms.&#10;- **Maintainability**: A well-designed RESTful API is easier to maintain and extend.&#10;- **Discoverability**: HATEOAS enables clients to discover available actions dynamically.&#10;&#10;By understanding and applying the REST Maturity Model, developers can design APIs that are robust, scalable, and aligned with modern web standards.&#10;&#10;---&#10;## Databases and Storage&#10;### Databases&#10;---&#10;### SQL vs NoSQL vs Object Store&#10;&#10;When designing a system, choosing the right data storage solution is crucial. The three main categories are **SQL databases**, **NoSQL databases**, and **Object Stores**. Each serves different use cases and has unique characteristics.&#10;&#10;#### SQL Databases (Relational Databases)&#10;&#10;- **Examples:** MySQL, PostgreSQL, Oracle, Microsoft SQL Server&#10;- **Data Model:** Structured, tabular data with predefined schemas (tables, rows, columns)&#10;- **Query Language:** SQL (Structured Query Language)&#10;- **Transactions:** Strong ACID guarantees (Atomicity, Consistency, Isolation, Durability)&#10;- **Use Cases:** Applications requiring complex queries, joins, and strong consistency (e.g., banking, ERP, CRM)&#10;- **Strengths:** Data integrity, complex querying, relationships, mature ecosystem&#10;- **Limitations:** Vertical scaling, rigid schema, less suited for unstructured or rapidly evolving data&#10;&#10;#### NoSQL Databases&#10;&#10;- **Examples:** MongoDB (Document), Cassandra (Wide-column), Redis (Key-Value), Neo4j (Graph)&#10;- **Data Model:** Flexible, can be document, key-value, column-family, or graph-based&#10;- **Schema:** Schema-less or dynamic schemas; can handle semi-structured or unstructured data&#10;- **Transactions:** Typically BASE properties (Basically Available, Soft state, Eventually consistent)&#10;- **Use Cases:** High scalability, large volumes of diverse data, real-time analytics, IoT, social networks&#10;- **Strengths:** Horizontal scaling, flexible data models, high write/read throughput&#10;- **Limitations:** Weaker consistency (eventual consistency), limited support for complex joins, less mature tooling&#10;&#10;#### Object Store&#10;&#10;- **Examples:** Amazon S3, Google Cloud Storage, Azure Blob Storage, MinIO&#10;- **Data Model:** Stores data as objects (blobs) with metadata and a unique identifier; no schema or tables&#10;- **Access:** Accessed via APIs (REST, SDKs); not a database—optimized for storing and retrieving large files&#10;- **Transactions:** No ACID/BASE guarantees; eventual consistency for some operations&#10;- **Use Cases:** Storing unstructured data (images, videos, backups, logs, large files), data lakes, static website hosting&#10;- **Strengths:** Virtually unlimited scalability, low cost for large data, durability, global access&#10;- **Limitations:** Not suitable for transactional data or complex queries; eventual consistency; slower for small, frequent reads/writes&#10;&#10;#### Comparison Table&#10;&#10;| Feature         | SQL (Relational)         | NoSQL                    | Object Store                |&#10;|-----------------|-------------------------|--------------------------|-----------------------------|&#10;| **Data Model**  | Tables (rows/columns)   | Flexible (JSON, KV, etc) | Objects (blobs + metadata)  |&#10;| **Schema**      | Fixed                   | Dynamic/Schema-less      | None                        |&#10;| **Query**       | SQL                     | Varies (NoSQL APIs)      | API (REST/S3)               |&#10;| **Transactions**| ACID                    | BASE (usually)           | None                        |&#10;| **Scaling**     | Vertical (mostly)       | Horizontal               | Horizontal                  |&#10;| **Best For**    | Structured, relational  | Semi/unstructured, scale | Unstructured, large files   |&#10;| **Examples**    | MySQL, PostgreSQL       | MongoDB, Cassandra       | S3, GCS, Azure Blob         |&#10;&#10;**Summary:**  &#10;- Use **SQL** for structured data and strong consistency.&#10;- Use **NoSQL** for flexible, scalable, high-throughput needs.&#10;- Use **Object Store** for unstructured, large-scale file storage—not as a database.&#10;&#10;---&#10;### Database Indexing&#10;---&#10;### Replication&#10;---&#10;### Sharding&#10;---&#10;### Vertical Partitioning&#10;---&#10;### Caching&#10;&#10;Caching is the process of storing frequently accessed data in a temporary storage layer to improve system performance and reduce latency. &#10;&#10;#### Advantages of Caching&#10;&#10;1. **Improved Performance**: Reduces response time by serving data from faster storage layers (e.g., memory).  &#10;&#10;2. **Reduced Latency**: Minimizes delays in data retrieval, enhancing user experience.  &#10;&#10;3. **Lower Database Load**: Decreases the number of direct queries to the database, reducing resource usage.  &#10;&#10;4. **Scalability**: Helps handle increased traffic by offloading requests from the primary data source.  &#10;&#10;5. **Cost Efficiency**: Reduces operational costs by optimizing resource utilization.  &#10;&#10;#### Disadvantages of Caching&#10;&#10;1. **Data Staleness**: Cached data may become outdated if not properly invalidated or refreshed.  &#10;&#10;2. **Complexity**: Implementing and managing caching layers adds complexity to the system.  &#10;&#10;3. **Cache Misses**: If data is not found in the cache, it can lead to slower performance as the system falls back to the original data source.  &#10;&#10;4. **Memory Overhead**: Caching requires additional memory, which can increase infrastructure costs.  &#10;&#10;5. **Consistency Challenges**: Ensuring data consistency between the cache and the source of truth can be difficult.  &#10;&#10;#### Strategies&#10;&#10;1. **Cache-Aside**: The application checks the cache first. If the data is not found, it fetches from the database and updates the cache. Commonly used for read-heavy workloads.  &#10;&#10;2. **Write-Through**: Data is written to the cache and the database simultaneously. Ensures data consistency but may introduce higher write latency.  &#10;&#10;3. **Write-Behind**: Data is written to the cache first and asynchronously updated in the database. Improves write performance but risks data loss during failures.  &#10;&#10;4. **Read-Through**: The application interacts only with the cache. If the data is not in the cache, the cache fetches it from the database. Simplifies application logic but adds complexity to the caching layer.  &#10;&#10;#### Measuring Cache Effectiveness&#10;&#10;1. **Calculate the Cache Hit Rate**: Measure the percentage of requests served from the cache versus the total requests. A high hit rate indicates effective caching.  &#10;&#10;2. **Analyze Cache Eviction Rate**: Monitor how often data is evicted from the cache due to capacity limits. Optimize cache size and eviction policies to reduce unnecessary evictions.  &#10;&#10;3. **Monitor Data Consistency**: Ensure that cached data remains consistent with the source of truth (e.g., database). Use appropriate invalidation and expiration mechanisms.  &#10;&#10;4. **Determine the Right Cache Expiration Time**: Set expiration times based on data usage patterns and freshness requirements. Avoid stale data while minimizing unnecessary cache misses.&#10;&#10;#### Example Use Cases for Caching&#10;&#10;1. **URL Shortener**: Cache `ShortCode → URL` mappings. Strategy: LRU for frequently accessed URLs.&#10;&#10;2. **User Profile Service**: Cache user profiles with TTL for frequent reads. Challenge: Cache invalidation and consistency.&#10;&#10;3. **Weather Forecast API**: Cache responses based on `city+date`. Set TTL based on forecast freshness.&#10;&#10;4. **Rate Limiter Service**: Cache token bucket or sliding window counters per user. Use Redis or in-memory store with expiration.&#10;&#10;5. **Product Catalog**: Cache product details at edge/CDN. Strategy: Write-through or refresh-on-write.&#10;&#10;6. **Twitter Feed**: Cache user timelines and precompute recent tweets. Eviction policy: LRU or LFU.&#10;&#10;7. **Geolocation Service**: Cache frequently accessed IP ranges. Use TTL for DNS/IP lookups.&#10;&#10;8. **Session Management**: Store sessions in Redis with TTL. Trade-off: In-memory vs database storage.&#10;&#10;9. **Distributed Cache System**: Handle replication vs partitioning. Prevent hot keys and cache stampede.&#10;&#10;10. **Online Code Editor**: Cache user preferences and recent submissions. Use client-side and server-side caching.&#10;&#10;#### References&#10;&#10;- [Cache Strategies - Medium](https://medium.com/@mmoshikoo/cache-strategies-996e91c80303)&#10;&#10;---&#10;### ACID vs BASE&#10;&#10;#### ACID Properties&#10;ACID stands for Atomicity, Consistency, Isolation, and Durability. These properties are essential for traditional relational databases to ensure reliable transactions:&#10;- **Atomicity**: Ensures that a transaction is all-or-nothing. If one part fails, the entire transaction is rolled back.&#10;- **Consistency**: Guarantees that a transaction brings the database from one valid state to another, maintaining all defined rules.Always preserve the data integrity.&#10;- **Isolation**: Ensures that concurrent transactions do not interfere with each other. Don't step on each other shoes. The various problems&#10;&#10;  | Isolation Level      | Dirty Reads | Non-Repeatable Reads | Phantom Reads | Description |&#10;  |----------------------|-------------|-----------------------|----------------|-------------|&#10;  | **Read Uncommitted** | ✅ Allowed  | ✅ Allowed            | ✅ Allowed     | Minimal isolation, allows all anomalies. |&#10;  | **Read Committed**   | ❌ Prevented| ✅ Allowed            | ✅ Allowed     | Only committed data is visible. Default in many databases. |&#10;  | **Repeatable Read**  | ❌ Prevented| ❌ Prevented          | ✅ Allowed     | Rows cannot change, but new rows may appear (phantoms). |&#10;  | **Serializable**     | ❌ Prevented| ❌ Prevented          | ❌ Prevented   | Full isolation, transactions execute as if sequentially. |&#10;&#10;  - **Dirty Read**: Transaction reads data written by another uncommitted transaction.Example: T1 reads a value updated by T2, but T2 hasn't committed. **Solution**: Use `Read Committed` or higher.&#10;  &#10;  - **Non-Repeatable Read**: A row is read twice and returns different data due to an update by another transaction. T1 reads a row, T2 updates and commits it, T1 reads again and gets different data. **Solution**: Use `Repeatable Read` or `Serializable`.&#10;&#10;  - **Phantom Read**: A query returns a different set of rows when re-executed because another transaction inserted/deleted matching rows.Example: T1 runs a query with a condition; T2 inserts a new matching row; T1 reruns and sees new row. **Solution**: Use `Serializable`, or databases supporting MVCC (like PostgreSQL or Oracle).&#10;&#10;- **Durability**: Once a transaction is committed, it remains so, even in the event of a system failure.&#10;### Distributed Transaction Protocols &amp; Patterns&#10;&#10;#### 1. Two-Phase Commit (2PC)&#10;&#10;**Goal:**  &#10;Ensure all participants in a distributed transaction either all commit or all roll back.&#10;&#10;**Roles:**&#10;- **Coordinator** — orchestrates the commit.&#10;- **Participants (Resource Managers)** — e.g., databases, queues.&#10;&#10;**Phases:**&#10;1. **Prepare phase**  &#10;   - Coordinator → Participants: *&quot;Can you commit?&quot;*  &#10;   - Participants:  &#10;     - Validate transaction feasibility (constraints, locks).  &#10;     - If OK → reply **YES** (and lock resources so they can commit later).  &#10;     - If not OK → reply **NO**.&#10;2. **Commit/Abort phase**  &#10;   - If **all YES** → Coordinator sends **COMMIT** to all.  &#10;   - If **any NO** → Coordinator sends **ROLLBACK** to all.&#10;&#10;**Pros:**&#10;- Strong consistency.&#10;- Simple to reason about.&#10;&#10;**Cons:**&#10;- **Blocking** — If coordinator crashes after prepare but before commit, participants wait indefinitely.&#10;- Locks held across prepare → commit can hurt performance.&#10;&#10;---&#10;&#10;#### 2. Three-Phase Commit (3PC)&#10;&#10;**Goal:**  &#10;Reduce 2PC blocking by adding a pre-commit phase.&#10;&#10;**Phases:**&#10;1. **Can Commit**  &#10;   - Same as 2PC’s prepare phase — ask if ready.&#10;2. **Pre-Commit**  &#10;   - If all **YES**: Coordinator sends **PRE-COMMIT** to participants.  &#10;   - Participants acknowledge, enter a state where they can commit without coordinator.&#10;3. **Do Commit**  &#10;   - Coordinator sends **COMMIT**.  &#10;   - If coordinator fails, participants can still commit safely after a timeout (based on pre-commit state).&#10;&#10;**Pros:**&#10;- Less blocking than 2PC.&#10;- Participants can make progress after coordinator failure.&#10;&#10;**Cons:**&#10;- Requires synchronous clocks and reliable network assumptions (rare in real-world WAN).&#10;- More message overhead.&#10;&#10;---&#10;&#10;#### 3. XA Transactions&#10;&#10;**Goal:**  &#10;Provide a standard API for distributed transactions across multiple resource managers.&#10;&#10;**Key Points:**&#10;- Defined by **X/Open XA** spec.&#10;- Involves:&#10;  - **Application** — business logic.&#10;  - **Transaction Manager (TM)** — controls transaction boundaries.&#10;  - **Resource Managers (RM)** — e.g., databases, message brokers.&#10;&#10;**Flow:**&#10;1. Application starts transaction (via TM).&#10;2. Application interacts with multiple RMs.&#10;3. TM calls RMs using XA API to prepare/commit.&#10;4. Under the hood, TM uses **2PC** protocol (almost always).&#10;&#10;**Important:**  &#10;XA is **not** a commit algorithm — it’s a coordination API/spec. But in practice, **XA + 2PC** is the norm.&#10;&#10;#### BASE Properties&#10;BASE stands for Basically Available, Soft state, and Eventually consistent. These properties are common in distributed systems and NoSQL databases:&#10;- **Basically Available**: The system guarantees availability, even in the presence of partial failures.&#10;- **Soft State**: The state of the system may change over time, even without input, due to eventual consistency.&#10;- **Eventually Consistent**: The system will become consistent over time, given that no new updates are made.&#10;&#10;&#10;| Feature                | ACID                                                                                     | BASE                                                                                     |&#10;|------------------------|------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------|&#10;| **Definition**         | Ensures reliable transactions with strong consistency and integrity.                     | Focuses on availability and eventual consistency in distributed systems.                 |&#10;| **Consistency**        | Strong consistency; the database is always in a valid state after a transaction.         | Eventual consistency; the system becomes consistent over time.                          |&#10;| **Availability**       | May sacrifice availability for consistency.                                              | Prioritizes availability, even during partial failures.                                  |&#10;| **Data Integrity**     | High data integrity; suitable for critical applications like banking.                    | Lower data integrity; suitable for scalable systems like social media.                  |&#10;| **Transaction Model**  | Transactions are all-or-nothing (atomic).                                                | Transactions may be partial or eventual.                                                |&#10;| **Use Case**           | Ideal for OLTP systems requiring strict data accuracy.                                   | Ideal for distributed systems requiring high scalability and availability.              |&#10;| **Examples**           | Relational databases like MySQL, PostgreSQL.                                             | NoSQL databases like Cassandra, DynamoDB.                                               |&#10;&#10;---&#10;### Normalization vs Denormalization&#10;&#10;#### Purpose of Normalization&#10;- Organize data to **reduce redundancy** and **improve integrity**.&#10;- Avoid:&#10;  - **Update anomalies**&#10;  - **Insertion anomalies**&#10;  - **Deletion anomalies**&#10;- Achieved by splitting data into well-structured tables and defining relationships.&#10;&#10;---&#10;&#10;#### 1. First Normal Form (1NF)&#10;**Rule:**&#10;- Each column contains **atomic values** (no repeating groups, no arrays).&#10;- Each row-column intersection holds **a single value**.&#10;- Each record must be **unique** (primary key present).&#10;&#10;**Example:**&#10;❌ `Hobbies: [Reading, Swimming]`  &#10;✅  &#10;| ID | Hobby    |&#10;|----|----------|&#10;| 1  | Reading  |&#10;| 1  | Swimming |&#10;&#10;---&#10;&#10;#### 2. Second Normal Form (2NF)&#10;**Prerequisite:** Must be in **1NF**  &#10;**Rule:**&#10;- No **partial dependency** — non-key attributes must depend on the **whole** primary key.&#10;- Applies only to tables with a **composite primary key**.&#10;&#10;**Example:**&#10;❌ `OrderID + ProductID → Quantity`, but `ProductName` depends only on `ProductID`.  &#10;✅ Move product details to a separate **Product** table.&#10;&#10;---&#10;&#10;#### 3. Third Normal Form (3NF)&#10;**Prerequisite:** Must be in **2NF**  &#10;**Rule:**&#10;- No **transitive dependency** — non-key attributes must depend **only** on the primary key.&#10;&#10;**Example:**&#10;❌ `StudentID → DepartmentID → DepartmentName`  &#10;✅ Store `DepartmentID → DepartmentName` in a separate table.&#10;&#10;---&#10;&#10;#### 4. Boyce–Codd Normal Form (BCNF)&#10;**Prerequisite:** Must be in **3NF**  &#10;**Rule:**&#10;- For **every functional dependency (X → Y)**, X must be a **superkey**.&#10;- Stricter than 3NF — resolves anomalies that 3NF may allow.&#10;&#10;---&#10;&#10;#### 5. Fourth Normal Form (4NF)&#10;**Prerequisite:** Must be in **BCNF**  &#10;**Rule:**&#10;- No **multi-valued dependencies** unless they are part of a candidate key.&#10;- Prevents storing unrelated multi-valued facts in the same table.&#10;&#10;**Example:**&#10;If a teacher teaches multiple subjects **and** speaks multiple languages:  &#10;- Store them in separate tables to avoid cross-product redundancy.&#10;&#10;---&#10;&#10;#### 6. Fifth Normal Form (5NF / Project-Join Normal Form)&#10;**Prerequisite:** Must be in **4NF**  &#10;**Rule:**&#10;- No **join dependency** — table should not be reconstructable from smaller tables in any **non-trivial** way.&#10;- Deals with complex relationships broken into **three or more** tables.&#10;&#10;---&#10;&#10;#### Quick Comparison Table&#10;&#10;| Form  | Removes…                 | Focus Area                     |&#10;|-------|--------------------------|---------------------------------|&#10;| 1NF   | Repeating groups, arrays | Atomic data                     |&#10;| 2NF   | Partial dependency       | Full key dependency             |&#10;| 3NF   | Transitive dependency    | Direct PK dependency            |&#10;| BCNF  | Any non-superkey FD      | Strict key dependency           |&#10;| 4NF   | Multi-valued dependency  | No unrelated multi-values       |&#10;| 5NF   | Join dependency          | Complex table reconstruction    |&#10;&#10;&#10;Normalization is the process of organizing data to reduce redundancy and improve data integrity, while denormalization involves combining data to optimize read performance by reducing the number of joins.&#10;&#10;| Feature                | Normalization                                                                 | Denormalization                                                              |&#10;|------------------------|-------------------------------------------------------------------------------|------------------------------------------------------------------------------|&#10;| **Definition**         | Organizing data to reduce redundancy and improve data integrity.             | Combining data to reduce the number of joins and improve read performance.   |&#10;| **Data Redundancy**    | Minimal redundancy; data is stored in separate, related tables.               | Increased redundancy; data is duplicated across tables.                      |&#10;| **Performance**        | Optimized for write operations and data integrity.                            | Optimized for read operations and query performance.                         |&#10;| **Complexity**         | Higher complexity due to multiple tables and relationships.                   | Lower complexity for queries but higher complexity for updates.              |&#10;| **Use Case**           | Suitable for OLTP systems where data integrity and consistency are critical.  | Suitable for OLAP systems where fast read performance is required.           |&#10;| **Storage**            | Requires less storage due to reduced redundancy.                              | Requires more storage due to duplicated data.                                |&#10;| **Maintenance**        | Easier to maintain data integrity and consistency.                            | Harder to maintain consistency due to data duplication.                      |&#10;&#10;---&#10;### CAP Theorem&#10;&#10;The **CAP Theorem**—also known as **Brewer’s Theorem**—states that in any distributed data system, it is **impossible to simultaneously guarantee** all three of the following properties:&#10;&#10;- **C** — **Consistency** - Every read receives the most recent write or an error. Equivalent to strong consistency across nodes.&#10;- **A** — **Availability** - Every request (read or write) receives a non-error response, without the guarantee that it contains the most recent write. The system is responsive even under stress.&#10;- **P** — **Partition Tolerance** - The system continues to operate despite arbitrary partitioning (network failures/loss of connectivity between nodes). Must handle message loss or delay. In any real-world distributed system. So the real choice is between **Consistency** and **Availability**.&#10;&#10;&#10;In practice, a system can **only guarantee two out of the three** at any given time. However with some complimenting strategies you can close to achieve the best of all for a given usecase. Remember the strongly and eventually consistant modes in case of Dynamodb.&#10;&#10;#### Design Trade-offs: Choosing Two&#10;&#10;| Type       | Properties Chosen | Trade-off |&#10;|------------|-------------------|-----------|&#10;| **CP**     | Consistency + Partition Tolerance | May reject requests during partition to preserve data integrity. |&#10;| **CA**     | Consistency + Availability | Not realistic in distributed systems since network partitions are unavoidable. |&#10;| **AP**     | Availability + Partition Tolerance | System may serve stale data or become eventually consistent. |&#10;&#10;#### Design Perspective: What to Choose?&#10;&#10;| Use Case | Recommended Trade-off | Reason |&#10;|----------|------------------------|--------|&#10;| **Banking/Financial Systems** | **CP** | Strong consistency is critical for correctness. |&#10;| **Social Media Feeds**        | **AP** | Availability is prioritized; slight staleness is acceptable. |&#10;| **E-commerce Carts**          | **AP** or **CP** | Depends on whether consistency (inventory) or uptime is more important. |&#10;| **Real-time Messaging**       | **AP** | Users expect availability; some eventual consistency is acceptable. |&#10;&#10;![](../cap.png)&#10;&#10;&gt; ⚠️ **Note**: CAP is a simplified model. In practice, systems also consider latency, throughput, durability, and more advanced consistency models like **Causal Consistency**, **Eventual Consistency**, and **Linearizability**.&#10;&#10;#### Linearizability (Strong Consistency)&#10;- Guarantees that all **operations appear to happen atomically and in a single, global order**.&#10;- Once a write completes, all subsequent reads must return that value or a newer one.&#10;- Operations appear **instantaneous** from the perspective of all clients.&#10;&#10;**Example**:&#10;- User A transfers $100 from Account X to Y.&#10;- User B queries Account X and sees the debited balance immediately.&#10;- No matter which server or region the users connect to, the order is preserved.&#10;&#10;**Pros**:&#10;- Predictable and intuitive behavior.&#10;- Ideal for critical systems (e.g., banking, ledgers).&#10;&#10;**Cons**:&#10;- Slower performance due to coordination overhead.&#10;- Difficult to scale globally.&#10;&#10;#### Causal Consistency (Eventual Consistency)&#10;- Guarantees that **causally related operations are seen in the same order by all nodes**.&#10;- Independent operations may be seen in different orders by different nodes.&#10;&#10;**Example**:&#10;- Alice posts: &quot;I love this product!&quot;&#10;- Bob replies: &quot;Me too!&quot;&#10;- Everyone should see Alice’s post **before** Bob’s reply — because the reply is causally dependent.&#10;&#10;**Pros**:&#10;- Faster and more scalable.&#10;- Sufficient for collaborative apps, chat, social networks.&#10;&#10;**Cons**:&#10;- Weaker guarantee: simultaneous updates may appear in different orders to different users.&#10;- Not suitable for systems needing strong accuracy guarantees.&#10;&#10;---&#10;&#10;### Blob Storage&#10;---&#10;## Scalability and Performance&#10;### Vertical and Horizontal Scaling&#10;&#10;Scaling is a critical aspect of system design that ensures a system can handle increased load or demand. There are two primary types of scaling: vertical scaling and horizontal scaling.&#10;Increase the power of a single machine.&#10;&#10;- **Methods:** Add CPU, RAM, faster storage, GPUs, etc.&#10;- **Pros:**&#10;  - Simple to implement&#10;  - Often no code change required&#10;- **Cons:**&#10;  - Hardware limits&#10;  - Expensive&#10;  - Single point of failure remains&#10;- **Example:** Upgrading a database server from 8 cores to 64 cores&#10;&#10;#### Vertical Scaling&#10;Vertical scaling, also known as &quot;scaling up,&quot; involves adding more resources (e.g., CPU, RAM, or storage) to a single machine. This approach is straightforward and often requires minimal changes to the application.&#10;&#10;**Advantages:**&#10;- Simplicity: Easier to implement and manage e.g. Postgres RDBMS Scaling up and down.&#10;- No need for distributed systems: Avoids complexities like data partitioning and synchronization.&#10;- Suitable for monolithic applications.&#10;&#10;**Disadvantages:**&#10;- Hardware limitations: There is a physical limit to how much a single machine can be upgraded.&#10;- Single point of failure: If the machine fails, the entire system goes down.&#10;- Cost: High-end hardware can be expensive.&#10;&#10;#### Horizontal Scaling&#10;Horizontal scaling, or &quot;scaling out,&quot; involves adding more machines to distribute the load. This approach is commonly used in distributed systems and cloud environments.&#10;&#10;**Advantages:**&#10;- Scalability: Can handle virtually unlimited growth by adding more machines.&#10;- Fault tolerance: Reduces the risk of a single point of failure.&#10;- Cost efficiency: Commodity hardware can be used instead of expensive high-end machines.&#10;&#10;**Disadvantages:**&#10;- Complexity: Requires distributed systems, load balancing, and data partitioning.&#10;- Consistency challenges: Ensuring data consistency across multiple nodes can be difficult.&#10;- Network overhead: Communication between nodes can introduce latency.&#10;&#10;#### Choosing Between Vertical and Horizontal Scaling&#10;- **When to use vertical scaling:**&#10;  - When the application is monolithic and not designed for distributed systems.&#10;  - When the load is predictable and within the limits of a single machine.&#10;  - When simplicity and quick implementation are priorities.&#10;&#10;- **When to use horizontal scaling:**&#10;  - When the system needs to handle unpredictable or massive growth.&#10;  - When fault tolerance and high availability are critical.&#10;  - When the application is designed as a distributed system.&#10;  - Easy in Cloud infrastructure - Pay per use or Pay as you go.&#10;&#10;#### Combining Vertical and Horizontal Scaling&#10;In practice, systems often use a combination of vertical and horizontal scaling. For example:&#10;- Start with vertical scaling for simplicity and quick deployment.&#10;- Transition to horizontal scaling as the system grows and requires higher availability.&#10;&#10;By understanding the trade-offs and leveraging efficient algorithms, you can design systems that scale effectively to meet user demands.&#10;&#10;### Vertical vs Horizontal Scaling&#10;&#10;Vertical scaling and horizontal scaling are two approaches to handle increased system load. Here's a comparison:&#10;&#10;| Feature                | Vertical Scaling                                                              | Horizontal Scaling                                                             |&#10;|------------------------|-------------------------------------------------------------------------------|------------------------------------------------------------------------------|&#10;| **Definition**         | Adding more resources (CPU, RAM, etc.) to a single machine.                  | Adding more machines to distribute the load.                                 |&#10;| **Scalability**        | Limited by the hardware capacity of a single machine.                        | Virtually unlimited by adding more machines.                                 |&#10;| **Fault Tolerance**    | Single point of failure; if the machine fails, the system goes down.         | Higher fault tolerance; failure of one machine does not affect the system.   |&#10;| **Complexity**         | Simpler to implement and manage.                                             | Requires distributed systems, load balancing, and data partitioning.         |&#10;| **Cost**               | High cost for high-end hardware.                                             | Cost-effective with commodity hardware.                                      |&#10;| **Use Case**           | Suitable for monolithic applications with predictable loads.                 | Suitable for distributed systems with unpredictable or massive growth.       |&#10;&#10;### Algorithmic Scaling&#10;&#10;Algorithmic scaling plays a crucial role in ensuring that systems can handle increased load efficiently. By leveraging efficient algorithms and data structures, you can optimize performance and scalability, often reducing the need for additional hardware or resources.&#10;![](../algoscaling.png)&#10;&#10;**Big O Notation:**&#10;Big O notation is used to describe the efficiency of an algorithm in terms of time and space complexity. Common complexities include:&#10;- **O(1):** Constant time. Example: Hash table lookups.&#10;- **O(log n):** Logarithmic time. Example: Binary search.&#10;- **O(n):** Linear time. Example: Iterating through a list.&#10;- **O(n log n):** Log-linear time. Example: Merge sort.&#10;- **O(n^2):** Quadratic time. Example: Nested loops.&#10;&#10;## 2️⃣ Distributed Scaling — The Scale Cube&#10;(*You already know these, so just the headings for completeness*)&#10;&#10;- **X-axis:** Horizontal duplication&#10;- **Y-axis:** Functional decomposition&#10;- **Z-axis:** Data partitioning&#10;&#10;---&#10;&#10;## 3️⃣ Additional Scaling Techniques (Beyond the Cube)&#10;&#10;### 3.1 Scaling by Caching&#10;Reduce load by storing frequently accessed results.  &#10;**Examples:** CDN, Redis, in-memory caches&#10;&#10;### 3.2 Scaling by Asynchrony &amp; Queues&#10;Smooth out load spikes by processing tasks asynchronously.  &#10;**Examples:** Message brokers, event-driven architecture&#10;&#10;### 3.3 Scaling by Algorithmic Efficiency&#10;Reduce the amount of work or make it faster.  &#10;**Examples:** Better data structures, batching, indexing&#10;&#10;### 3.4 Scaling by Concurrency Model&#10;Handle more work in parallel.  &#10;**Examples:** Async I/O, multi-threading, actor model&#10;&#10;### 3.5 Scaling Geographically&#10;Deploy systems in multiple regions for latency and failover benefits.  &#10;**Examples:** Multi-region deployments, edge computing&#10;&#10;---&#10;&#10;## Layered View&#10;&#10;1. **First Layer** → Vertical scaling (make one box stronger)&#10;2. **Second Layer** → Scale Cube (X, Y, Z axes for distribution)&#10;3. **Third Layer** → Optimizations (caching, async, efficiency, concurrency, geo-distribution)&#10;&#10;### Examples of Big O Notation in Java&#10;&#10;#### O(1) - Constant Time&#10;```java&#10;public int getFirstElement(int[] array) {&#10;    return array[0]; // Accessing the first element is constant time.&#10;}&#10;```&#10;&#10;#### O(log n) - Logarithmic Time&#10;```java&#10;public int binarySearch(int[] array, int target) {&#10;    int left = 0, right = array.length - 1;&#10;    while (left &lt;= right) {&#10;        int mid = left + (right - left) / 2;&#10;        if (array[mid] == target) {&#10;            return mid; // Found the target.&#10;        } else if (array[mid] &lt; target) {&#10;            left = mid + 1; // Search in the right half.&#10;        } else {&#10;            right = mid - 1; // Search in the left half.&#10;        }&#10;    }&#10;    return -1; // Target not found.&#10;}&#10;```&#10;&#10;#### O(n) - Linear Time&#10;```java&#10;public int findMax(int[] array) {&#10;    int max = array[0];&#10;    for (int num : array) {&#10;        if (num &gt; max) {&#10;            max = num; // Update max if a larger number is found.&#10;        }&#10;    }&#10;    return max;&#10;}&#10;```&#10;&#10;#### O(n log n) - Log-Linear Time&#10;```java&#10;import java.util.Arrays;&#10;&#10;public void sortArray(int[] array) {&#10;    Arrays.sort(array); // Sorting an array using a comparison-based algorithm like Merge Sort.&#10;}&#10;```&#10;&#10;#### O(n^2) - Quadratic Time&#10;```java&#10;public void printAllPairs(int[] array) {&#10;    for (int i = 0; i &lt; array.length; i++) {&#10;        for (int j = 0; j &lt; array.length; j++) {&#10;            System.out.println(array[i] + &quot;, &quot; + array[j]); // Print all pairs.&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;#### O(2^n) - Exponential Time&#10;```java&#10;public int fibonacci(int n) {&#10;    if (n &lt;= 1) {&#10;        return n; // Base case.&#10;    }&#10;    return fibonacci(n - 1) + fibonacci(n - 2); // Recursive calls.&#10;}&#10;```&#10;&#10;#### O(n!) - Factorial Time&#10;```java&#10;public void generatePermutations(String str, String perm) {&#10;    if (str.isEmpty()) {&#10;        System.out.println(perm); // Print a permutation.&#10;        return;&#10;    }&#10;    for (int i = 0; i &lt; str.length(); i++) {&#10;        char ch = str.charAt(i);&#10;        String remaining = str.substring(0, i) + str.substring(i + 1);&#10;        generatePermutations(remaining, perm + ch); // Recursive call.&#10;    }&#10;}&#10;```&#10;&#10;### Load Balancers&#10;### Rate Limiting&#10;### Content Delivery Optimization&#10;### Zero Downtime Deployment&#10;---&#10;## Common Design Patterns and Architecture&#10;### Event-Driven Architecture&#10;### Data Partitioning Strategies&#10;### Eventual Consistency&#10;### Leader Election&#10;### Circuit Breaker Pattern&#10;### Throttling and Backpressure&#10;### Service Discovery&#10;### Microservices&#10;### Message Queues&#10;---&#10;## Monitoring, Resiliency, and Security&#10;### Monitoring and Observability&#10;### Data Compression&#10;### Authentication and Authorization&#10;### Data Backup and Recovery&#10;### Chaos Engineering&#10;---&#10;## Development and Deployment&#10;### Concurrency Control&#10;### Immutable Infrastructure&#10;### Blue-Green Deployment&#10;---&#10;## Theoretical Concepts&#10;### Search Systems&#10;---&#10;## Data Processing&#10;### Data Streaming&#10;---&#10;## Miscellaneous&#10;### Rate Shaping&#10;---&#10;## Laws&#10;### General Engineering &amp; Design Principles&#10;* Murphy’s Law – “Anything that can go wrong will go wrong.” → Build for resilience and failure recovery.&#10;&#10;* Gall’s Law – Complex systems that work evolve from simple systems that work.&#10;&#10;* Occam’s Razor – Prefer the simplest solution that meets the requirements.&#10;&#10;* KISS Principle – “Keep It Simple, Stupid.” Avoid unnecessary complexity.&#10;&#10;* YAGNI – “You Aren’t Gonna Need It.” Don’t implement features until they are actually needed.&#10;&#10;* DRY Principle – “Don’t Repeat Yourself.” Centralize logic to avoid duplication.&#10;&#10;* Robustness Principle (Postel’s Law) – Be conservative in what you send, liberal in what you accept.&#10;&#10;### Time, Effort, and Estimation&#10;* Hofstadter’s Law – “It always takes longer than you expect, even when you take into account Hofstadter’s Law.”&#10;&#10;* Parkinson’s Law – “Work expands to fill the time available for its completion.”&#10;&#10;* Brooks’s Law – “Adding manpower to a late software project makes it later.” (From The Mythical Man-Month)&#10;&#10;* Ninety-Ninety Rule – The first 90% of the code accounts for the first 90% of the development time; the remaining 10% of the code accounts for the other 90% of the development time.&#10;&#10;* Pareto Principle (80/20 Rule) – 80% of the effects come from 20% of the causes; focus on the critical 20%.&#10;&#10;### People, Teams, and Communication&#10;* Conway’s Law – System design mirrors the communication structure of the organization.&#10;&#10;* Peter Principle – People rise to their level of incompetence.&#10;&#10;* Linus’s Law – “Given enough eyeballs, all bugs are shallow.” (Open-source development insight)&#10;&#10;* Law of Triviality (Parkinson’s Law of Triviality) – People spend disproportionate time on trivial issues (bike-shedding).&#10;&#10;### Code Quality &amp; Maintainability&#10;* Law of Demeter – Talk only to your immediate collaborators; avoid unnecessary coupling.&#10;&#10;* Boyle’s Law of Code – Code will expand to fill all available complexity.&#10;&#10;* Hyrum’s Law – With enough users, all observable behaviors of your system will be relied upon, intentional or not.&#10;&#10;* LeBlanc’s Law – “Later equals never.” If you say you’ll fix it later, you probably won’t.&#10;&#10;* Zawinski’s Law – Every program attempts to expand until it can read mail; those that cannot are replaced by ones that can.&#10;&#10;### Reliability &amp; Risk&#10;* Finagle’s Law – Anything that can go wrong, will—at the worst possible time.&#10;&#10;* Sod’s Law – Similar to Murphy’s Law, but with more emphasis on timing and bad luck.&#10;&#10;* Schneier’s Law – Anyone can create an encryption algorithm they themselves cannot break; that doesn’t mean it’s secure." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/themes/gravionis/layouts/_partials/header.html">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/themes/gravionis/layouts/_partials/header.html" />
              <option name="originalContent" value="&lt;div style=&quot;position: fixed; top: 0; left: 0; width: 100vw; height: 64px; background: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.03); z-index: 201; display: flex; flex-direction: row; align-items: center; padding: 0 2rem;&quot;&gt;&#10;  &lt;h1 style=&quot;margin: 0 2rem 0 0; font-size: 1.5rem;&quot;&gt;{{ site.Title }}&lt;/h1&gt;&#10;  &lt;nav style=&quot;height: 100%; display: flex; align-items: center; margin-left: auto;&quot;&gt;&#10;    {{ partial &quot;menu.html&quot; (dict &quot;menuID&quot; &quot;main&quot; &quot;page&quot; .) }}&#10;  &lt;/nav&gt;&#10;&lt;/div&gt;&#10;&lt;!-- Add extra top margin to main content to shift blogs below the header --&gt;&#10;&lt;style&gt;&#10;  body {&#10;    margin-top: 64px; /* Header height */&#10;    margin-left: 2.5rem; /* Increased left margin for posts */&#10;    font-size: 0.95rem;&#10;  }&#10;  @media (max-width: 600px) {&#10;    body {&#10;      margin-top: 56px;&#10;      margin-left: 1rem; /* Slightly increased margin on mobile */&#10;      font-size: 1rem;&#10;    }&#10;    .top-menu {&#10;      display: none;&#10;    }&#10;  }&#10;  /* Glow effect for menu items on hover */&#10;  .menu-glow:hover {&#10;    box-shadow: 0 0 8px 2px #0078ff, 0 0 2px 1px #fff;&#10;    background: #f0f8ff;&#10;    color: #0078ff !important;&#10;    transition: box-shadow 0.2s, background 0.2s, color 0.2s;&#10;  }&#10;&lt;/style&gt;&#10;" />
              <option name="updatedContent" value="&lt;div style=&quot;position: fixed; top: 0; left: 0; width: 100vw; height: 64px; background: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.03); z-index: 201; display: flex; flex-direction: row; align-items: center; padding: 0 2rem;&quot;&gt;&#10;  &lt;h1 style=&quot;margin: 0 2rem 0 0; font-size: 1.5rem;&quot;&gt;{{ site.Title }}&lt;/h1&gt;&#10;  &lt;div style=&quot;flex: 1; display: flex; justify-content: center;&quot;&gt;&#10;    &lt;nav style=&quot;height: 100%; display: flex; align-items: center;&quot;&gt;&#10;      {{ partial &quot;menu.html&quot; (dict &quot;menuID&quot; &quot;main&quot; &quot;page&quot; .) }}&#10;    &lt;/nav&gt;&#10;  &lt;/div&gt;&#10;&lt;/div&gt;&#10;&lt;!-- Add extra top margin to main content to shift blogs below the header --&gt;&#10;&lt;style&gt;&#10;  body {&#10;    margin-top: 64px; /* Header height */&#10;    margin-left: 2.5rem; /* Increased left margin for posts */&#10;    font-size: 0.95rem;&#10;  }&#10;  @media (max-width: 600px) {&#10;    body {&#10;      margin-top: 56px;&#10;      margin-left: 1rem; /* Slightly increased margin on mobile */&#10;      font-size: 1rem;&#10;    }&#10;    .top-menu {&#10;      display: none;&#10;    }&#10;  }&#10;  /* Glow effect for menu items on hover */&#10;  .menu-glow:hover {&#10;    box-shadow: 0 0 8px 2px #0078ff, 0 0 2px 1px #fff;&#10;    background: #f0f8ff;&#10;    color: #0078ff !important;&#10;    transition: box-shadow 0.2s, background 0.2s, color 0.2s;&#10;  }&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/themes/gravionis/layouts/_partials/menu.html">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/themes/gravionis/layouts/_partials/menu.html" />
              <option name="originalContent" value="{{- /*&#10;Renders a menu for the given menu ID.&#10;&#10;@context {page} page The current page.&#10;@context {string} menuID The menu ID.&#10;&#10;@example: {{ partial &quot;menu.html&quot; (dict &quot;menuID&quot; &quot;main&quot; &quot;page&quot; .) }}&#10;*/}}&#10;&#10;{{- $page := .page }}&#10;{{- $menuID := .menuID }}&#10;&#10;{{- with index site.Menus $menuID }}&#10;  &lt;nav style=&quot;margin-top:0;&quot;&gt;&#10;    &lt;ul style=&quot;display: flex; flex-direction: row; gap: 1.5rem; list-style: none; margin: 0; padding: 0;&quot;&gt;&#10;      {{- partial &quot;inline/menu/walk.html&quot; (dict &quot;page&quot; $page &quot;menuEntries&quot; .) }}&#10;    &lt;/ul&gt;&#10;  &lt;/nav&gt;&#10;{{- end }}&#10;&#10;{{- define &quot;_partials/inline/menu/walk.html&quot; }}&#10;  {{- $page := .page }}&#10;  {{- range .menuEntries }}&#10;    {{- $attrs := dict &quot;href&quot; .URL }}&#10;    {{- if $page.IsMenuCurrent .Menu . }}&#10;      {{- $attrs = merge $attrs (dict &quot;class&quot; &quot;active&quot; &quot;aria-current&quot; &quot;page&quot;) }}&#10;    {{- else if $page.HasMenuCurrent .Menu .}}&#10;      {{- $attrs = merge $attrs (dict &quot;class&quot; &quot;ancestor&quot; &quot;aria-current&quot; &quot;true&quot;) }}&#10;    {{- end }}&#10;    {{- $name := .Name }}&#10;    {{- with .Identifier }}&#10;      {{- with T . }}&#10;        {{- $name = . }}&#10;      {{- end }}&#10;    {{- end }}&#10;    &lt;li&gt;&#10;      &lt;a&#10;        {{- range $k, $v := $attrs }}&#10;          {{- with $v }}&#10;            {{- printf &quot; %s=%q&quot; $k $v | safeHTMLAttr }}&#10;          {{- end }}&#10;        {{- end -}}&#10;      &gt;{{ $name }}&lt;/a&gt;&#10;      {{- with .Children }}&#10;        &lt;ul&gt;&#10;          {{- partial &quot;inline/menu/walk.html&quot; (dict &quot;page&quot; $page &quot;menuEntries&quot; .) }}&#10;        &lt;/ul&gt;&#10;      {{- end }}&#10;    &lt;/li&gt;&#10;  {{- end }}&#10;{{- end }}&#10;" />
              <option name="updatedContent" value="{{- /*&#10;Renders a menu for the given menu ID.&#10;&#10;@context {page} page The current page.&#10;@context {string} menuID The menu ID.&#10;&#10;@example: {{ partial &quot;menu.html&quot; (dict &quot;menuID&quot; &quot;main&quot; &quot;page&quot; .) }}&#10;*/}}&#10;&#10;{{- $page := .page }}&#10;{{- $menuID := .menuID }}&#10;&#10;{{- with index site.Menus $menuID }}&#10;  &lt;nav style=&quot;margin-top:0;&quot;&gt;&#10;    &lt;ul style=&quot;display: flex; flex-direction: row; gap: 1.5rem; list-style: none; margin: 0; padding: 0; justify-content: center;&quot;&gt;&#10;      {{- partial &quot;inline/menu/walk.html&quot; (dict &quot;page&quot; $page &quot;menuEntries&quot; .) }}&#10;    &lt;/ul&gt;&#10;  &lt;/nav&gt;&#10;{{- end }}&#10;&#10;{{- define &quot;_partials/inline/menu/walk.html&quot; }}&#10;  {{- $page := .page }}&#10;  {{- range .menuEntries }}&#10;    {{- $attrs := dict &quot;href&quot; .URL }}&#10;    {{- if $page.IsMenuCurrent .Menu . }}&#10;      {{- $attrs = merge $attrs (dict &quot;class&quot; &quot;active&quot; &quot;aria-current&quot; &quot;page&quot;) }}&#10;    {{- else if $page.HasMenuCurrent .Menu .}}&#10;      {{- $attrs = merge $attrs (dict &quot;class&quot; &quot;ancestor&quot; &quot;aria-current&quot; &quot;true&quot;) }}&#10;    {{- end }}&#10;    {{- $name := .Name }}&#10;    {{- with .Identifier }}&#10;      {{- with T . }}&#10;        {{- $name = . }}&#10;      {{- end }}&#10;    {{- end }}&#10;    &lt;li&gt;&#10;      &lt;a&#10;        {{- range $k, $v := $attrs }}&#10;          {{- with $v }}&#10;            {{- printf &quot; %s=%q&quot; $k $v | safeHTMLAttr }}&#10;          {{- end }}&#10;        {{- end -}}&#10;      &gt;{{ $name }}&lt;/a&gt;&#10;      {{- with .Children }}&#10;        &lt;ul&gt;&#10;          {{- partial &quot;inline/menu/walk.html&quot; (dict &quot;page&quot; $page &quot;menuEntries&quot; .) }}&#10;        &lt;/ul&gt;&#10;      {{- end }}&#10;    &lt;/li&gt;&#10;  {{- end }}&#10;{{- end }}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>