<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/content/posts/ai/generative_ai_aws.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/content/posts/ai/generative_ai_aws.md" />
              <option name="originalContent" value="+++&#10;date = '2025-05-10T12:44:47+10:00'&#10;draft = false&#10;title = 'Gen AI on AWS'&#10;tags = ['Agentic AI']&#10;+++&#10;&#10;AWS provides a complete ecosystem for generative AI, including infrastructure, foundation models, managed services, governance, and enablement. &#10;AWS's approach to generative AI is designed to support organizations at every stage of their AI journey—from initial experimentation to large-scale production deployments. The platform offers a tightly integrated set of services that cover the entire lifecycle of generative AI solutions, including secure and scalable infrastructure, access to leading foundation models, robust tools for customization and deployment, and built-in safety and governance features. &#10;&#10;## **Motivation: LLM Strategies and Design Patterns on AWS**&#10;&#10;Modern generative AI applications rely on proven strategies and design patterns for large language models (LLMs)—such as retrieval-augmented generation (RAG), multi-agent orchestration, prompt engineering, and secure context enrichment. AWS's generative AI ecosystem is purpose-built to enable these patterns at scale and with enterprise-grade reliability.&#10;&#10;- **Retrieval-Augmented Generation (RAG):** AWS Bedrock and SageMaker support RAG workflows by integrating vector stores, knowledge bases, and secure data pipelines, allowing LLMs to ground outputs in enterprise data.&#10;- **Multi-Agent Systems:** Bedrock Agents and Amazon Q provide orchestration and agentic workflows, enabling complex automation and reasoning patterns described in LLM design strategies.&#10;- **Prompt Engineering &amp; Structured Output:** AWS services offer tools for prompt management, output formatting, and function calling, supporting robust prompt engineering and structured output patterns.&#10;- **Governance &amp; Safety:** Guardrails, automated reasoning, and prescriptive guidance ensure responsible AI adoption, aligning with best practices for security, compliance, and human-in-the-loop workflows.&#10;- **Enablement &amp; Integration:** Training, marketplace solutions, and partner integrations make it easy to adopt advanced LLM strategies and patterns, accelerating innovation and reducing time-to-value.&#10;&#10;By leveraging AWS's generative AI stack, organizations can implement the latest LLM strategies and design patterns with confidence, scalability, and operational excellence.&#10;&#10;## **AWS Services and Features**&#10;&#10;&lt;img width=&quot;1471&quot; height=&quot;1347&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/3a9f1ef6-f05d-4ebc-98e7-40b697a96952&quot; /&gt;&#10;&#10;source: https://aws.amazon.com/blogs/machine-learning/architect-a-mature-generative-ai-foundation-on-aws/&#10;&#10;&#10;| **Category**                | **Service / Feature**                       | **Description** |&#10;|-----------------------------|--------------------------------------------|-----------------|&#10;| **Foundation &amp; Deployment** | **Amazon Bedrock** | Fully managed platform providing access to multiple foundation models (Anthropic Claude, Cohere, Stability AI, etc.), enabling customization, RAG, guardrails, and agent creation. |&#10;|                             | **Amazon SageMaker** | End-to-end ML platform for training, deploying, and managing generative AI models. Includes JumpStart, fine-tuning, pipelines, and integrated tools for experimentation. |&#10;|                             | **AI Infrastructure** | High-performance hardware for generative AI workloads (EC2 P5 instances with NVIDIA H100 GPUs, AWS Trainium &amp; Inferentia for cost-efficient training and inference). |&#10;|                             | **Amazon Nova** | AWS’s own foundation model family optimized for performance and scalability. |&#10;| **Generative AI Applications** | **Amazon Q (Business &amp; Developer)** | Pre-built assistants leveraging Bedrock for business workflows and developer productivity. |&#10;|                             | **Amazon Bedrock Agents** | Enables building and orchestrating multi-agent systems for automated workflows and task execution. |&#10;|                             | **Model Distillation** | AWS tools to compress large models into smaller, cost-efficient versions without major performance loss. |&#10;| **Safety &amp; Responsible AI** | **Guardrails in Bedrock** | Pre-built safety and moderation features to prevent harmful or inappropriate outputs. |&#10;|                             | **Automated Reasoning** | Logic-based system for verifying correctness and enforcing compliance in model outputs. |&#10;| **Data &amp; Context Enrichment** | **Knowledge Bases &amp; RAG** | Retrieval-Augmented Generation support in Bedrock for grounding models with enterprise data. |&#10;|                             | **AWS Data Foundation Services** | Secure, scalable data infrastructure for high-quality pipelines to feed generative AI systems. |&#10;| **Architecture &amp; Best Practices** | **Generative AI Stack &amp; Lens** | Layered architecture and AWS Well-Architected Generative AI Lens for building scalable and secure solutions. |&#10;|                             | **Prescriptive Guidance** | Reference architectures and patterns for enterprise-ready generative AI adoption. |&#10;| **Training &amp; Enablement** | **Innovation Center** | AWS experts help with strategy, roadmapping, and adoption of generative AI in enterprises. |&#10;|                             | **Training Courses** | Courses like “Generative AI Essentials” and “Developing Generative AI Applications” to build expertise. |&#10;| **Marketplace &amp; Partner Ecosystem** | **AWS Marketplace GenAI Solutions** | Curated marketplace for third-party generative AI tools, foundation models, and services. |&#10;|                             | **Partner Integrations** | Integrations with partners (e.g., Pegasystems, Loka) for advanced workflows and modernization. |&#10;&#10;---&#10;&#10;## **AWS Generative AI Architecture**&#10;- **Infrastructure Layer**: Compute optimized for AI (GPU clusters, Trainium, Inferentia)&#10;- **Foundation Model Layer**: Bedrock, SageMaker, Amazon Nova&#10;- **Application Layer**: Amazon Q, Bedrock Agents, Custom Apps&#10;- **Safety Layer**: Guardrails, Automated Reasoning&#10;- **Governance &amp; Best Practices**: Well-Architected Lens, Prescriptive Guidance&#10;- **Enablement**: Training, Marketplace, Partner Solutions&#10;&#10;---&#10;&#10;### ✅ Key Highlights:&#10;- **Amazon Bedrock**: No infrastructure management, easy access to multiple FMs, supports RAG, agents, and guardrails.&#10;- **SageMaker**: Custom model training and tuning.&#10;- **Guardrails**: Inherent safety layer for enterprise-grade solutions.&#10;- **AI Infrastructure**: Cost-effective, high-performance chips and clusters for large-scale generative AI.&#10;- **Enablement &amp; Governance**: Frameworks, training, and partner solutions for enterprise readiness.&#10;&#10;---&#10;" />
              <option name="updatedContent" value="+++&#10;date = '2025-05-10T12:44:47+10:00'&#10;draft = false&#10;title = 'Gen AI on AWS'&#10;tags = ['Agentic AI']&#10;+++&#10;&#10;# Generative AI on AWS: Strategies, Patterns, and Enterprise Enablement&#10;&#10;AWS provides a complete ecosystem for generative AI, including infrastructure, foundation models, managed services, governance, and enablement.  &#10;AWS's approach to generative AI is designed to support organizations at every stage of their AI journey—from initial experimentation to large-scale production deployments. The platform offers a tightly integrated set of services that cover the entire lifecycle of generative AI solutions, including secure and scalable infrastructure, access to leading foundation models, robust tools for customization and deployment, and built-in safety and governance features.&#10;&#10;---&#10;&#10;## Table of Contents&#10;&#10;- [Motivation: Why AWS for Generative AI?](#motivation-why-aws-for-generative-ai)&#10;- [Core Concepts](#core-concepts)&#10;- [Key AWS Services &amp; Features](#key-aws-services--features)&#10;- [LLM Strategies &amp; Design Patterns on AWS](#llm-strategies--design-patterns-on-aws)&#10;  - [Retrieval-Augmented Generation (RAG)](#retrieval-augmented-generation-rag)&#10;  - [Multi-Agent Orchestration](#multi-agent-orchestration)&#10;  - [Prompt Engineering &amp; Structured Output](#prompt-engineering--structured-output)&#10;  - [Governance &amp; Safety](#governance--safety)&#10;  - [Enablement &amp; Integration](#enablement--integration)&#10;- [Architecture &amp; Best Practices](#architecture--best-practices)&#10;- [Practical Patterns: AWS Mapping](#practical-patterns-aws-mapping)&#10;- [Summary &amp; Key Takeaways](#summary--key-takeaways)&#10;&#10;---&#10;&#10;## Motivation: Why AWS for Generative AI?&#10;&#10;Modern generative AI applications rely on proven strategies and design patterns for large language models (LLMs)—such as retrieval-augmented generation (RAG), multi-agent orchestration, prompt engineering, and secure context enrichment. AWS's generative AI ecosystem is purpose-built to enable these patterns at scale and with enterprise-grade reliability.&#10;&#10;- **Breadth of Services:** AWS offers infrastructure, model access, orchestration, safety, and enablement in a unified platform.&#10;- **Enterprise Readiness:** Security, compliance, and governance are built-in, supporting regulated industries.&#10;- **Pattern Enablement:** AWS services directly support advanced LLM strategies and design patterns, accelerating innovation.&#10;&#10;---&#10;&#10;## Core Concepts&#10;&#10;### Foundation Models (FMs)&#10;- Pre-trained generative models (text, image, code) available via Amazon Bedrock, SageMaker, and Amazon Nova.&#10;- Support for customization, fine-tuning, and multi-modal inputs.&#10;&#10;### Managed Services&#10;- **Amazon Bedrock:** Unified API for multiple FMs, agentic workflows, RAG, and guardrails.&#10;- **SageMaker:** End-to-end ML lifecycle management, including training, deployment, and pipelines.&#10;&#10;### Infrastructure&#10;- High-performance compute (EC2 P5, Trainium, Inferentia) for scalable, cost-effective AI workloads.&#10;&#10;### Safety &amp; Governance&#10;- Guardrails, automated reasoning, and compliance frameworks for responsible AI.&#10;&#10;### Enablement&#10;- Training, expert guidance, and marketplace solutions for rapid adoption.&#10;&#10;---&#10;&#10;## Key AWS Services &amp; Features&#10;&#10;| **Category**                | **Service / Feature**                       | **Description** |&#10;|-----------------------------|--------------------------------------------|-----------------|&#10;| **Foundation &amp; Deployment** | **Amazon Bedrock** | Managed platform for FMs, customization, RAG, guardrails, agents. |&#10;|                             | **Amazon SageMaker** | ML platform for training, deploying, and managing generative AI models. |&#10;|                             | **AI Infrastructure** | EC2 P5, Trainium, Inferentia for high-performance workloads. |&#10;|                             | **Amazon Nova** | AWS’s own FM family, optimized for scale. |&#10;| **Generative AI Applications** | **Amazon Q** | Pre-built assistants for business and developer workflows. |&#10;|                             | **Bedrock Agents** | Multi-agent orchestration for automated workflows. |&#10;|                             | **Model Distillation** | Tools for compressing large models. |&#10;| **Safety &amp; Responsible AI** | **Guardrails in Bedrock** | Safety and moderation features. |&#10;|                             | **Automated Reasoning** | Compliance and correctness verification. |&#10;| **Data &amp; Context Enrichment** | **Knowledge Bases &amp; RAG** | RAG support for grounding models in enterprise data. |&#10;|                             | **AWS Data Foundation Services** | Secure, scalable data pipelines. |&#10;| **Architecture &amp; Best Practices** | **GenAI Stack &amp; Lens** | Layered architecture, Well-Architected Lens. |&#10;|                             | **Prescriptive Guidance** | Reference architectures and patterns. |&#10;| **Training &amp; Enablement** | **Innovation Center** | Strategy and adoption support. |&#10;|                             | **Training Courses** | Generative AI Essentials, application development. |&#10;| **Marketplace &amp; Partner Ecosystem** | **Marketplace GenAI Solutions** | Third-party tools, models, and services. |&#10;|                             | **Partner Integrations** | Advanced workflows and modernization. |&#10;&#10;---&#10;&#10;## LLM Strategies &amp; Design Patterns on AWS&#10;&#10;### Retrieval-Augmented Generation (RAG)&#10;&#10;- **Pattern:** Combine LLMs with enterprise data for grounded, accurate outputs.&#10;- **AWS Mapping:** Bedrock Knowledge Bases, SageMaker, vector stores, secure data pipelines.&#10;- **Example:** Use Bedrock to retrieve context from S3 or DynamoDB, enrich prompts, and generate answers.&#10;&#10;### Multi-Agent Orchestration&#10;&#10;- **Pattern:** Coordinate multiple agents for complex workflows (reasoning, tool use, automation).&#10;- **AWS Mapping:** Bedrock Agents, Amazon Q, Step Functions for workflow orchestration.&#10;- **Example:** Build a support bot that delegates tasks to specialized agents (retrieval, summarization, compliance).&#10;&#10;### Prompt Engineering &amp; Structured Output&#10;&#10;- **Pattern:** Design prompts for clarity, context, and structured responses (JSON, tables).&#10;- **AWS Mapping:** Bedrock prompt templates, function calling, output formatting tools.&#10;- **Example:** Use Bedrock’s function calling to ensure outputs are machine-readable for downstream automation.&#10;&#10;### Governance &amp; Safety&#10;&#10;- **Pattern:** Enforce safety, compliance, and human-in-the-loop workflows.&#10;- **AWS Mapping:** Bedrock Guardrails, automated reasoning, Well-Architected Lens.&#10;- **Example:** Moderate outputs, log interactions, and require human approval for sensitive actions.&#10;&#10;### Enablement &amp; Integration&#10;&#10;- **Pattern:** Accelerate adoption with training, expert guidance, and partner solutions.&#10;- **AWS Mapping:** Innovation Center, training courses, Marketplace integrations.&#10;- **Example:** Use AWS training to upskill teams and integrate third-party models via Marketplace.&#10;&#10;---&#10;&#10;## Architecture &amp; Best Practices&#10;&#10;- **Layered Stack:** Infrastructure → Foundation Models → Applications → Safety → Governance → Enablement.&#10;- **Scalability:** Use EC2 P5, Trainium, and Inferentia for cost-effective scaling.&#10;- **Security:** Data encryption, access controls, audit logging, and compliance frameworks.&#10;- **Operational Excellence:** Monitoring, automation, and prescriptive guidance for reliability.&#10;&#10;---&#10;&#10;## Practical Patterns: AWS Mapping&#10;&#10;### RAG Workflow Example&#10;&#10;```python&#10;# Retrieve context from Bedrock Knowledge Base&#10;context = bedrock.retrieve_context(query, knowledge_base_id=&quot;kb-123&quot;)&#10;&#10;# Generate answer using a foundation model&#10;response = bedrock.generate(&#10;    prompt=f&quot;Answer using context: {context}\nQuestion: {query}&quot;,&#10;    model_id=&quot;anthropic.claude-v2&quot;&#10;)&#10;```&#10;&#10;### Multi-Agent Orchestration Example&#10;&#10;```python&#10;# Define agents for retrieval, summarization, and compliance&#10;agents = [&#10;    BedrockAgent(role=&quot;retriever&quot;, task=&quot;fetch context&quot;),&#10;    BedrockAgent(role=&quot;summarizer&quot;, task=&quot;summarize context&quot;),&#10;    BedrockAgent(role=&quot;compliance&quot;, task=&quot;check output&quot;)&#10;]&#10;&#10;# Orchestrate workflow&#10;workflow = StepFunctionsWorkflow(agents)&#10;result = workflow.run(query)&#10;```&#10;&#10;### Guardrails Example&#10;&#10;```python&#10;# Apply guardrails to model output&#10;safe_response = bedrock.apply_guardrails(&#10;    output=response,&#10;    rules=[&quot;no PII&quot;, &quot;no harmful content&quot;]&#10;)&#10;```&#10;&#10;---&#10;&#10;## Summary &amp; Key Takeaways&#10;&#10;- **AWS enables advanced generative AI strategies and design patterns with enterprise-grade reliability.**&#10;- **Bedrock, SageMaker, and supporting services map directly to LLM best practices (RAG, multi-agent, prompt engineering, safety).**&#10;- **Built-in governance, enablement, and integration accelerate innovation and reduce risk.**&#10;- **Adopt AWS’s layered architecture and prescriptive guidance for scalable, secure, and responsible generative AI solutions.**&#10;&#10;---" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/content/posts/system_design/core_design_patterns.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/content/posts/system_design/core_design_patterns.md" />
              <option name="originalContent" value="+++&#10;date = '2024-05-03T12:44:47+10:00'&#10;draft = false&#10;title = '23 Core Design Patterns'&#10;tags = ['Core Design Patterns', 'Interview']&#10;+++&#10;&#10;About Core Design Patterns.&#10;&#10;## Table of Contents&#10;&#10;- [Creational Patterns](#creational-patterns)&#10;  - [Singleton](#singleton)&#10;  - [Factory Method](#factory-method)&#10;  - [Abstract Factory](#abstract-factory)&#10;  - [Builder](#builder)&#10;  - [Prototype](#prototype)&#10;- [Structural Patterns](#structural-patterns)&#10;  - [Adapter](#adapter)&#10;  - [Bridge](#bridge)&#10;  - [Composite](#composite)&#10;  - [Decorator](#decorator)&#10;  - [Facade](#facade)&#10;  - [Flyweight](#flyweight)&#10;  - [Proxy](#proxy)&#10;- [Behavioral Patterns](#behavioral-patterns)&#10;  - [Chain of Responsibility](#chain-of-responsibility)&#10;  - [Command](#command)&#10;  - [Interpreter](#interpreter)&#10;  - [Iterator](#iterator)&#10;  - [Mediator](#mediator)&#10;  - [Memento](#memento)&#10;  - [Observer](#observer)&#10;  - [State](#state)&#10;  - [Strategy](#strategy)&#10;  - [Template Method](#template-method)&#10;  - [Visitor](#visitor)&#10;- [Summary](#summary)&#10;&#10;---&#10;&#10;## Creational Patterns&#10;&#10;### Singleton&#10;&#10;Ensures a class has only one instance and provides a global point of access to it.&#10;&#10;**Example (Java):**&#10;```java&#10;public class Singleton {&#10;    private static Singleton uniqueInstance;&#10;    private Singleton() {}&#10;    public static synchronized Singleton getInstance() {&#10;        if (uniqueInstance == null) {&#10;            uniqueInstance = new Singleton();&#10;        }&#10;        return uniqueInstance;&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need a single shared resource (e.g., config, logger, cache).&#10;&#10;**When not to use:**  &#10;&#10;- When you need multiple instances (e.g., for testing, parallelism).&#10;- Can introduce hidden dependencies and global state.&#10;&#10;---&#10;&#10;### Factory Method&#10;&#10;Defines an interface for creating an object, but lets subclasses decide which class to instantiate.&#10;&#10;**Example (Java):**&#10;```java&#10;public abstract class Animal {&#10;    public abstract String speak();&#10;}&#10;&#10;public class Dog extends Animal {&#10;    public String speak() { return &quot;Woof!&quot;; }&#10;}&#10;&#10;public class Cat extends Animal {&#10;    public String speak() { return &quot;Meow!&quot;; }&#10;}&#10;&#10;public abstract class AnimalFactory {&#10;    public abstract Animal createAnimal();&#10;}&#10;&#10;public class DogFactory extends AnimalFactory {&#10;    public Animal createAnimal() { return new Dog(); }&#10;}&#10;&#10;public class CatFactory extends AnimalFactory {&#10;    public Animal createAnimal() { return new Cat(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When a class can't anticipate the type of objects it needs to create.&#10;&#10;**When not to use:**  &#10;&#10;- When object creation is simple and doesn't need abstraction.&#10;&#10;---&#10;&#10;### Abstract Factory&#10;&#10;Provides an interface for creating families of related or dependent objects without specifying their concrete classes.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Button {&#10;    void paint();&#10;}&#10;&#10;public class WinButton implements Button {&#10;    public void paint() { System.out.println(&quot;Windows Button&quot;); }&#10;}&#10;&#10;public class MacButton implements Button {&#10;    public void paint() { System.out.println(&quot;Mac Button&quot;); }&#10;}&#10;&#10;public interface GUIFactory {&#10;    Button createButton();&#10;}&#10;&#10;public class WinFactory implements GUIFactory {&#10;    public Button createButton() { return new WinButton(); }&#10;}&#10;&#10;public class MacFactory implements GUIFactory {&#10;    public Button createButton() { return new MacButton(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to create families of related objects.&#10;&#10;**When not to use:**  &#10;&#10;- When products don't need to be related.&#10;&#10;---&#10;&#10;### Builder&#10;&#10;Separates the construction of a complex object from its representation.&#10;&#10;**Example (Java):**&#10;```java&#10;public class Burger {&#10;    private boolean cheese;&#10;    private boolean lettuce;&#10;&#10;    public static class Builder {&#10;        private boolean cheese;&#10;        private boolean lettuce;&#10;&#10;        public Builder addCheese() {&#10;            cheese = true;&#10;            return this;&#10;        }&#10;        public Builder addLettuce() {&#10;            lettuce = true;&#10;            return this;&#10;        }&#10;        public Burger build() {&#10;            Burger burger = new Burger();&#10;            burger.cheese = this.cheese;&#10;            burger.lettuce = this.lettuce;&#10;            return burger;&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When constructing complex objects step by step.&#10;&#10;**When not to use:**  &#10;&#10;- For simple objects with few parameters.&#10;&#10;---&#10;&#10;### Prototype&#10;&#10;Creates new objects by copying an existing object.&#10;&#10;**Example (Java):**&#10;```java&#10;public abstract class Prototype implements Cloneable {&#10;    public Prototype clone() {&#10;        try {&#10;            return (Prototype) super.clone();&#10;        } catch (CloneNotSupportedException e) {&#10;            throw new AssertionError();&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When object creation is costly and similar objects are needed.&#10;&#10;**When not to use:**  &#10;&#10;- When objects are simple or copying is not needed.&#10;&#10;---&#10;&#10;## Structural Patterns&#10;&#10;### Adapter&#10;&#10;Allows incompatible interfaces to work together.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface USASocket {&#10;    int voltage();&#10;}&#10;&#10;public class EuropeanSocket {&#10;    public int voltage() { return 230; }&#10;}&#10;&#10;public class SocketAdapter implements USASocket {&#10;    private EuropeanSocket europeanSocket;&#10;    public SocketAdapter(EuropeanSocket socket) {&#10;        this.europeanSocket = socket;&#10;    }&#10;    public int voltage() {&#10;        return europeanSocket.voltage();&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When integrating with legacy or third-party code.&#10;&#10;**When not to use:**  &#10;&#10;- When you can refactor code directly.&#10;&#10;---&#10;&#10;### Bridge&#10;&#10;Separates abstraction from implementation.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface DrawingAPI {&#10;    void drawCircle(int x, int y, int r);&#10;}&#10;&#10;public class DrawingAPI1 implements DrawingAPI {&#10;    public void drawCircle(int x, int y, int r) {&#10;        System.out.println(&quot;API1: Circle at &quot; + x + &quot;,&quot; + y + &quot; radius &quot; + r);&#10;    }&#10;}&#10;&#10;public abstract class Shape {&#10;    protected DrawingAPI api;&#10;    public Shape(DrawingAPI api) { this.api = api; }&#10;    public abstract void draw();&#10;}&#10;&#10;public class Circle extends Shape {&#10;    private int x, y, r;&#10;    public Circle(int x, int y, int r, DrawingAPI api) {&#10;        super(api);&#10;        this.x = x; this.y = y; this.r = r;&#10;    }&#10;    public void draw() { api.drawCircle(x, y, r); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When abstraction and implementation should vary independently.&#10;&#10;**When not to use:**  &#10;&#10;- When only one implementation is needed.&#10;&#10;---&#10;&#10;### Composite&#10;&#10;Composes objects into tree structures.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Component {&#10;    void operation();&#10;}&#10;&#10;public class Leaf implements Component {&#10;    public void operation() { System.out.println(&quot;Leaf&quot;); }&#10;}&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class Composite implements Component {&#10;    private List&lt;Component&gt; children = new ArrayList&lt;&gt;();&#10;    public void add(Component component) { children.add(component); }&#10;    public void operation() {&#10;        for (Component child : children) {&#10;            child.operation();&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to treat individual and composite objects uniformly.&#10;&#10;**When not to use:**  &#10;&#10;- When hierarchy is not needed.&#10;&#10;---&#10;&#10;### Decorator&#10;&#10;Adds new functionality to an object dynamically.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Coffee {&#10;    int cost();&#10;}&#10;&#10;public class SimpleCoffee implements Coffee {&#10;    public int cost() { return 5; }&#10;}&#10;&#10;public class MilkDecorator implements Coffee {&#10;    private Coffee coffee;&#10;    public MilkDecorator(Coffee coffee) { this.coffee = coffee; }&#10;    public int cost() { return coffee.cost() + 2; }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to add responsibilities to objects dynamically.&#10;&#10;**When not to use:**  &#10;&#10;- When subclassing is simpler.&#10;&#10;---&#10;&#10;### Facade&#10;&#10;Provides a simplified interface to a complex subsystem.&#10;&#10;**Example (Java):**&#10;```java&#10;public class CPU { public void freeze() {} }&#10;public class Memory { public void load(int pos, String data) {} }&#10;&#10;public class ComputerFacade {&#10;    private CPU cpu;&#10;    private Memory memory;&#10;    public ComputerFacade() {&#10;        cpu = new CPU();&#10;        memory = new Memory();&#10;    }&#10;    public void start() {&#10;        cpu.freeze();&#10;        memory.load(0, &quot;data&quot;);&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you want to provide a simple interface to a complex system.&#10;&#10;**When not to use:**  &#10;&#10;- When subsystem is already simple.&#10;&#10;---&#10;&#10;### Flyweight&#10;&#10;Reduces memory usage by sharing data.&#10;&#10;**Example (Java):**&#10;```java&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class Flyweight {&#10;    private String shared;&#10;    public Flyweight(String shared) { this.shared = shared; }&#10;}&#10;&#10;public class FlyweightFactory {&#10;    private Map&lt;String, Flyweight&gt; flyweights = new HashMap&lt;&gt;();&#10;    public Flyweight getFlyweight(String shared) {&#10;        if (!flyweights.containsKey(shared)) {&#10;            flyweights.put(shared, new Flyweight(shared));&#10;        }&#10;        return flyweights.get(shared);&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When many objects share common data.&#10;&#10;**When not to use:**  &#10;&#10;- When objects are unique.&#10;&#10;---&#10;&#10;### Proxy&#10;&#10;Provides a surrogate for another object.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Subject {&#10;    void request();&#10;}&#10;&#10;public class RealSubject implements Subject {&#10;    public void request() { System.out.println(&quot;RealSubject&quot;); }&#10;}&#10;&#10;public class Proxy implements Subject {&#10;    private RealSubject real;&#10;    public Proxy(RealSubject real) { this.real = real; }&#10;    public void request() {&#10;        System.out.println(&quot;Proxy: Checking access&quot;);&#10;        real.request();&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For access control, lazy loading, logging.&#10;&#10;**When not to use:**  &#10;&#10;- When direct access is acceptable.&#10;&#10;---&#10;&#10;## Behavioral Patterns&#10;&#10;### Chain of Responsibility&#10;&#10;Passes a request along a chain of handlers.&#10;&#10;**Example (Java):**&#10;```java&#10;public abstract class Handler {&#10;    protected Handler next;&#10;    public void setNext(Handler next) { this.next = next; }&#10;    public void handle(String request) {&#10;        if (next != null) next.handle(request);&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When multiple objects can handle a request.&#10;&#10;**When not to use:**  &#10;&#10;- When only one handler is needed.&#10;&#10;---&#10;&#10;### Command&#10;&#10;Encapsulates a request as an object.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Command {&#10;    void execute();&#10;}&#10;&#10;public class LightOnCommand implements Command {&#10;    public void execute() { System.out.println(&quot;Light On&quot;); }&#10;}&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class Remote {&#10;    private List&lt;Command&gt; commands = new ArrayList&lt;&gt;();&#10;    public void addCommand(Command cmd) { commands.add(cmd); }&#10;    public void run() {&#10;        for (Command cmd : commands) { cmd.execute(); }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For undo/redo, queuing, logging.&#10;&#10;**When not to use:**  &#10;&#10;- When simple method calls suffice.&#10;&#10;---&#10;&#10;### Interpreter&#10;&#10;Defines a grammar and provides an interpreter.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Expression {&#10;    int interpret();&#10;}&#10;&#10;public class Number implements Expression {&#10;    private int value;&#10;    public Number(int value) { this.value = value; }&#10;    public int interpret() { return value; }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For languages, expressions, parsing.&#10;&#10;**When not to use:**  &#10;&#10;- For simple or infrequent grammar.&#10;&#10;---&#10;&#10;### Iterator&#10;&#10;Provides a way to access elements sequentially.&#10;&#10;**Example (Java):**&#10;```java&#10;import java.util.Iterator;&#10;import java.util.List;&#10;&#10;public class MyIterator implements Iterator&lt;String&gt; {&#10;    private List&lt;String&gt; collection;&#10;    private int index = 0;&#10;    public MyIterator(List&lt;String&gt; collection) { this.collection = collection; }&#10;    public boolean hasNext() { return index &lt; collection.size(); }&#10;    public String next() { return collection.get(index++); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to traverse a collection.&#10;&#10;**When not to use:**  &#10;&#10;- When direct access is sufficient.&#10;&#10;---&#10;&#10;### Mediator&#10;&#10;Encapsulates how objects interact.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Mediator {&#10;    void notify(Component sender, String event);&#10;}&#10;&#10;public class Component {&#10;    private Mediator mediator;&#10;    public Component(Mediator mediator) { this.mediator = mediator; }&#10;    public void doSomething() { mediator.notify(this, &quot;event&quot;); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When objects communicate in complex ways.&#10;&#10;**When not to use:**  &#10;&#10;- When communication is simple.&#10;&#10;---&#10;&#10;### Memento&#10;&#10;Captures and restores an object's state.&#10;&#10;**Example (Java):**&#10;```java&#10;public class Memento {&#10;    private String state;&#10;    public Memento(String state) { this.state = state; }&#10;    public String getState() { return state; }&#10;}&#10;&#10;public class Originator {&#10;    private String state;&#10;    public void setState(String state) { this.state = state; }&#10;    public Memento save() { return new Memento(state); }&#10;    public void restore(Memento memento) { state = memento.getState(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For undo/redo functionality.&#10;&#10;**When not to use:**  &#10;&#10;- When state is simple or not needed.&#10;&#10;---&#10;&#10;### Observer&#10;&#10;One-to-many dependency so dependents are notified of changes.&#10;&#10;**Example (Java):**&#10;```java&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public interface Observer {&#10;    void update();&#10;}&#10;&#10;public class Subject {&#10;    private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();&#10;    public void attach(Observer obs) { observers.add(obs); }&#10;    public void notifyObservers() {&#10;        for (Observer obs : observers) { obs.update(); }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For event handling, UI updates.&#10;&#10;**When not to use:**  &#10;&#10;- When only one object needs notification.&#10;&#10;---&#10;&#10;### State&#10;&#10;Alters behavior when internal state changes.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface State {&#10;    void handle();&#10;}&#10;&#10;public class Context {&#10;    private State state;&#10;    public Context(State state) { this.state = state; }&#10;    public void request() { state.handle(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When object behavior depends on state.&#10;&#10;**When not to use:**  &#10;&#10;- When state changes are rare.&#10;&#10;---&#10;&#10;### Strategy&#10;&#10;Encapsulates interchangeable algorithms.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Strategy {&#10;    int execute(int[] data);&#10;}&#10;&#10;public class SortStrategy implements Strategy {&#10;    public int execute(int[] data) {&#10;        java.util.Arrays.sort(data);&#10;        return data[0]; // Just for demonstration&#10;    }&#10;}&#10;&#10;public class Context {&#10;    private Strategy strategy;&#10;    public Context(Strategy strategy) { this.strategy = strategy; }&#10;    public int doTask(int[] data) { return strategy.execute(data); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When multiple algorithms are needed.&#10;&#10;**When not to use:**  &#10;&#10;- When only one algorithm is used.&#10;&#10;---&#10;&#10;### Template Method&#10;&#10;Defines the skeleton of an algorithm, deferring steps to subclasses.&#10;&#10;**Example (Java):**&#10;```java&#10;public abstract class AbstractClass {&#10;    public final void templateMethod() {&#10;        step1();&#10;        step2();&#10;    }&#10;    protected abstract void step1();&#10;    protected abstract void step2();&#10;}&#10;&#10;public class ConcreteClass extends AbstractClass {&#10;    protected void step1() { System.out.println(&quot;Step 1&quot;); }&#10;    protected void step2() { System.out.println(&quot;Step 2&quot;); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When algorithms have invariant steps.&#10;&#10;**When not to use:**  &#10;&#10;- When steps never change.&#10;&#10;---&#10;&#10;### Visitor&#10;&#10;Represents an operation to be performed on elements of an object structure.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Visitor {&#10;    void visit(Element element);&#10;}&#10;&#10;public interface Element {&#10;    void accept(Visitor visitor);&#10;}&#10;&#10;public class ConcreteElement implements Element {&#10;    public void accept(Visitor visitor) { visitor.visit(this); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to perform operations on object structures.&#10;&#10;**When not to use:**  &#10;&#10;- When object structure rarely changes.&#10;&#10;---&#10;&#10;## Summary&#10;&#10;The 23 core design patterns (Gang of Four) are essential tools for software engineers.  &#10;They provide proven solutions to common problems in software design, improve code maintainability, and are frequently discussed in interviews.  &#10;Understanding these patterns helps you write flexible, scalable, and robust code.&#10;" />
              <option name="updatedContent" value="+++&#10;date = '2025-05-03T12:44:47+10:00'&#10;draft = false&#10;title = '23 Core Design Patterns'&#10;tags = ['Core Design Patterns', 'Interview']&#10;+++&#10;&#10;Core design patterns are proven solutions to common software engineering problems. They help structure code for flexibility, scalability, and maintainability. Mastering these patterns is essential for interviews and for building robust, reusable, and understandable software systems.&#10;&#10;## Table of Contents&#10;&#10;- [Creational Patterns](#creational-patterns)&#10;  - [Singleton](#singleton)&#10;  - [Factory Method](#factory-method)&#10;  - [Abstract Factory](#abstract-factory)&#10;  - [Builder](#builder)&#10;  - [Prototype](#prototype)&#10;- [Structural Patterns](#structural-patterns)&#10;  - [Adapter](#adapter)&#10;  - [Bridge](#bridge)&#10;  - [Composite](#composite)&#10;  - [Decorator](#decorator)&#10;  - [Facade](#facade)&#10;  - [Flyweight](#flyweight)&#10;  - [Proxy](#proxy)&#10;- [Behavioral Patterns](#behavioral-patterns)&#10;  - [Chain of Responsibility](#chain-of-responsibility)&#10;  - [Command](#command)&#10;  - [Interpreter](#interpreter)&#10;  - [Iterator](#iterator)&#10;  - [Mediator](#mediator)&#10;  - [Memento](#memento)&#10;  - [Observer](#observer)&#10;  - [State](#state)&#10;  - [Strategy](#strategy)&#10;  - [Template Method](#template-method)&#10;  - [Visitor](#visitor)&#10;- [Summary](#summary)&#10;&#10;---&#10;&#10;## Creational Patterns&#10;&#10;### Singleton&#10;&#10;Ensures a class has only one instance and provides a global point of access to it.&#10;&#10;**Example (Java):**&#10;```java&#10;public class Singleton {&#10;    private static Singleton uniqueInstance;&#10;    private Singleton() {}&#10;    public static synchronized Singleton getInstance() {&#10;        if (uniqueInstance == null) {&#10;            uniqueInstance = new Singleton();&#10;        }&#10;        return uniqueInstance;&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need a single shared resource (e.g., config, logger, cache).&#10;&#10;**When not to use:**  &#10;&#10;- When you need multiple instances (e.g., for testing, parallelism).&#10;- Can introduce hidden dependencies and global state.&#10;&#10;---&#10;&#10;### Factory Method&#10;&#10;Defines an interface for creating an object, but lets subclasses decide which class to instantiate.&#10;&#10;**Example (Java):**&#10;```java&#10;public abstract class Animal {&#10;    public abstract String speak();&#10;}&#10;&#10;public class Dog extends Animal {&#10;    public String speak() { return &quot;Woof!&quot;; }&#10;}&#10;&#10;public class Cat extends Animal {&#10;    public String speak() { return &quot;Meow!&quot;; }&#10;}&#10;&#10;public abstract class AnimalFactory {&#10;    public abstract Animal createAnimal();&#10;}&#10;&#10;public class DogFactory extends AnimalFactory {&#10;    public Animal createAnimal() { return new Dog(); }&#10;}&#10;&#10;public class CatFactory extends AnimalFactory {&#10;    public Animal createAnimal() { return new Cat(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When a class can't anticipate the type of objects it needs to create.&#10;&#10;**When not to use:**  &#10;&#10;- When object creation is simple and doesn't need abstraction.&#10;&#10;---&#10;&#10;### Abstract Factory&#10;&#10;Provides an interface for creating families of related or dependent objects without specifying their concrete classes.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Button {&#10;    void paint();&#10;}&#10;&#10;public class WinButton implements Button {&#10;    public void paint() { System.out.println(&quot;Windows Button&quot;); }&#10;}&#10;&#10;public class MacButton implements Button {&#10;    public void paint() { System.out.println(&quot;Mac Button&quot;); }&#10;}&#10;&#10;public interface GUIFactory {&#10;    Button createButton();&#10;}&#10;&#10;public class WinFactory implements GUIFactory {&#10;    public Button createButton() { return new WinButton(); }&#10;}&#10;&#10;public class MacFactory implements GUIFactory {&#10;    public Button createButton() { return new MacButton(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to create families of related objects.&#10;&#10;**When not to use:**  &#10;&#10;- When products don't need to be related.&#10;&#10;---&#10;&#10;### Builder&#10;&#10;Separates the construction of a complex object from its representation.&#10;&#10;**Example (Java):**&#10;```java&#10;public class Burger {&#10;    private boolean cheese;&#10;    private boolean lettuce;&#10;&#10;    public static class Builder {&#10;        private boolean cheese;&#10;        private boolean lettuce;&#10;&#10;        public Builder addCheese() {&#10;            cheese = true;&#10;            return this;&#10;        }&#10;        public Builder addLettuce() {&#10;            lettuce = true;&#10;            return this;&#10;        }&#10;        public Burger build() {&#10;            Burger burger = new Burger();&#10;            burger.cheese = this.cheese;&#10;            burger.lettuce = this.lettuce;&#10;            return burger;&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When constructing complex objects step by step.&#10;&#10;**When not to use:**  &#10;&#10;- For simple objects with few parameters.&#10;&#10;---&#10;&#10;### Prototype&#10;&#10;Creates new objects by copying an existing object.&#10;&#10;**Example (Java):**&#10;```java&#10;public abstract class Prototype implements Cloneable {&#10;    public Prototype clone() {&#10;        try {&#10;            return (Prototype) super.clone();&#10;        } catch (CloneNotSupportedException e) {&#10;            throw new AssertionError();&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When object creation is costly and similar objects are needed.&#10;&#10;**When not to use:**  &#10;&#10;- When objects are simple or copying is not needed.&#10;&#10;---&#10;&#10;## Structural Patterns&#10;&#10;### Adapter&#10;&#10;Allows incompatible interfaces to work together.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface USASocket {&#10;    int voltage();&#10;}&#10;&#10;public class EuropeanSocket {&#10;    public int voltage() { return 230; }&#10;}&#10;&#10;public class SocketAdapter implements USASocket {&#10;    private EuropeanSocket europeanSocket;&#10;    public SocketAdapter(EuropeanSocket socket) {&#10;        this.europeanSocket = socket;&#10;    }&#10;    public int voltage() {&#10;        return europeanSocket.voltage();&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When integrating with legacy or third-party code.&#10;&#10;**When not to use:**  &#10;&#10;- When you can refactor code directly.&#10;&#10;---&#10;&#10;### Bridge&#10;&#10;Separates abstraction from implementation.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface DrawingAPI {&#10;    void drawCircle(int x, int y, int r);&#10;}&#10;&#10;public class DrawingAPI1 implements DrawingAPI {&#10;    public void drawCircle(int x, int y, int r) {&#10;        System.out.println(&quot;API1: Circle at &quot; + x + &quot;,&quot; + y + &quot; radius &quot; + r);&#10;    }&#10;}&#10;&#10;public abstract class Shape {&#10;    protected DrawingAPI api;&#10;    public Shape(DrawingAPI api) { this.api = api; }&#10;    public abstract void draw();&#10;}&#10;&#10;public class Circle extends Shape {&#10;    private int x, y, r;&#10;    public Circle(int x, int y, int r, DrawingAPI api) {&#10;        super(api);&#10;        this.x = x; this.y = y; this.r = r;&#10;    }&#10;    public void draw() { api.drawCircle(x, y, r); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When abstraction and implementation should vary independently.&#10;&#10;**When not to use:**  &#10;&#10;- When only one implementation is needed.&#10;&#10;---&#10;&#10;### Composite&#10;&#10;Composes objects into tree structures.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Component {&#10;    void operation();&#10;}&#10;&#10;public class Leaf implements Component {&#10;    public void operation() { System.out.println(&quot;Leaf&quot;); }&#10;}&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class Composite implements Component {&#10;    private List&lt;Component&gt; children = new ArrayList&lt;&gt;();&#10;    public void add(Component component) { children.add(component); }&#10;    public void operation() {&#10;        for (Component child : children) {&#10;            child.operation();&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to treat individual and composite objects uniformly.&#10;&#10;**When not to use:**  &#10;&#10;- When hierarchy is not needed.&#10;&#10;---&#10;&#10;### Decorator&#10;&#10;Adds new functionality to an object dynamically.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Coffee {&#10;    int cost();&#10;}&#10;&#10;public class SimpleCoffee implements Coffee {&#10;    public int cost() { return 5; }&#10;}&#10;&#10;public class MilkDecorator implements Coffee {&#10;    private Coffee coffee;&#10;    public MilkDecorator(Coffee coffee) { this.coffee = coffee; }&#10;    public int cost() { return coffee.cost() + 2; }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to add responsibilities to objects dynamically.&#10;&#10;**When not to use:**  &#10;&#10;- When subclassing is simpler.&#10;&#10;---&#10;&#10;### Facade&#10;&#10;Provides a simplified interface to a complex subsystem.&#10;&#10;**Example (Java):**&#10;```java&#10;public class CPU { public void freeze() {} }&#10;public class Memory { public void load(int pos, String data) {} }&#10;&#10;public class ComputerFacade {&#10;    private CPU cpu;&#10;    private Memory memory;&#10;    public ComputerFacade() {&#10;        cpu = new CPU();&#10;        memory = new Memory();&#10;    }&#10;    public void start() {&#10;        cpu.freeze();&#10;        memory.load(0, &quot;data&quot;);&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you want to provide a simple interface to a complex system.&#10;&#10;**When not to use:**  &#10;&#10;- When subsystem is already simple.&#10;&#10;---&#10;&#10;### Flyweight&#10;&#10;Reduces memory usage by sharing data.&#10;&#10;**Example (Java):**&#10;```java&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class Flyweight {&#10;    private String shared;&#10;    public Flyweight(String shared) { this.shared = shared; }&#10;}&#10;&#10;public class FlyweightFactory {&#10;    private Map&lt;String, Flyweight&gt; flyweights = new HashMap&lt;&gt;();&#10;    public Flyweight getFlyweight(String shared) {&#10;        if (!flyweights.containsKey(shared)) {&#10;            flyweights.put(shared, new Flyweight(shared));&#10;        }&#10;        return flyweights.get(shared);&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When many objects share common data.&#10;&#10;**When not to use:**  &#10;&#10;- When objects are unique.&#10;&#10;---&#10;&#10;### Proxy&#10;&#10;Provides a surrogate for another object.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Subject {&#10;    void request();&#10;}&#10;&#10;public class RealSubject implements Subject {&#10;    public void request() { System.out.println(&quot;RealSubject&quot;); }&#10;}&#10;&#10;public class Proxy implements Subject {&#10;    private RealSubject real;&#10;    public Proxy(RealSubject real) { this.real = real; }&#10;    public void request() {&#10;        System.out.println(&quot;Proxy: Checking access&quot;);&#10;        real.request();&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For access control, lazy loading, logging.&#10;&#10;**When not to use:**  &#10;&#10;- When direct access is acceptable.&#10;&#10;---&#10;&#10;## Behavioral Patterns&#10;&#10;### Chain of Responsibility&#10;&#10;Passes a request along a chain of handlers.&#10;&#10;**Example (Java):**&#10;```java&#10;public abstract class Handler {&#10;    protected Handler next;&#10;    public void setNext(Handler next) { this.next = next; }&#10;    public void handle(String request) {&#10;        if (next != null) next.handle(request);&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When multiple objects can handle a request.&#10;&#10;**When not to use:**  &#10;&#10;- When only one handler is needed.&#10;&#10;---&#10;&#10;### Command&#10;&#10;Encapsulates a request as an object.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Command {&#10;    void execute();&#10;}&#10;&#10;public class LightOnCommand implements Command {&#10;    public void execute() { System.out.println(&quot;Light On&quot;); }&#10;}&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class Remote {&#10;    private List&lt;Command&gt; commands = new ArrayList&lt;&gt;();&#10;    public void addCommand(Command cmd) { commands.add(cmd); }&#10;    public void run() {&#10;        for (Command cmd : commands) { cmd.execute(); }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For undo/redo, queuing, logging.&#10;&#10;**When not to use:**  &#10;&#10;- When simple method calls suffice.&#10;&#10;---&#10;&#10;### Interpreter&#10;&#10;Defines a grammar and provides an interpreter.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Expression {&#10;    int interpret();&#10;}&#10;&#10;public class Number implements Expression {&#10;    private int value;&#10;    public Number(int value) { this.value = value; }&#10;    public int interpret() { return value; }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For languages, expressions, parsing.&#10;&#10;**When not to use:**  &#10;&#10;- For simple or infrequent grammar.&#10;&#10;---&#10;&#10;### Iterator&#10;&#10;Provides a way to access elements sequentially.&#10;&#10;**Example (Java):**&#10;```java&#10;import java.util.Iterator;&#10;import java.util.List;&#10;&#10;public class MyIterator implements Iterator&lt;String&gt; {&#10;    private List&lt;String&gt; collection;&#10;    private int index = 0;&#10;    public MyIterator(List&lt;String&gt; collection) { this.collection = collection; }&#10;    public boolean hasNext() { return index &lt; collection.size(); }&#10;    public String next() { return collection.get(index++); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to traverse a collection.&#10;&#10;**When not to use:**  &#10;&#10;- When direct access is sufficient.&#10;&#10;---&#10;&#10;### Mediator&#10;&#10;Encapsulates how objects interact.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Mediator {&#10;    void notify(Component sender, String event);&#10;}&#10;&#10;public class Component {&#10;    private Mediator mediator;&#10;    public Component(Mediator mediator) { this.mediator = mediator; }&#10;    public void doSomething() { mediator.notify(this, &quot;event&quot;); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When objects communicate in complex ways.&#10;&#10;**When not to use:**  &#10;&#10;- When communication is simple.&#10;&#10;---&#10;&#10;### Memento&#10;&#10;Captures and restores an object's state.&#10;&#10;**Example (Java):**&#10;```java&#10;public class Memento {&#10;    private String state;&#10;    public Memento(String state) { this.state = state; }&#10;    public String getState() { return state; }&#10;}&#10;&#10;public class Originator {&#10;    private String state;&#10;    public void setState(String state) { this.state = state; }&#10;    public Memento save() { return new Memento(state); }&#10;    public void restore(Memento memento) { state = memento.getState(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For undo/redo functionality.&#10;&#10;**When not to use:**  &#10;&#10;- When state is simple or not needed.&#10;&#10;---&#10;&#10;### Observer&#10;&#10;One-to-many dependency so dependents are notified of changes.&#10;&#10;**Example (Java):**&#10;```java&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public interface Observer {&#10;    void update();&#10;}&#10;&#10;public class Subject {&#10;    private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();&#10;    public void attach(Observer obs) { observers.add(obs); }&#10;    public void notifyObservers() {&#10;        for (Observer obs : observers) { obs.update(); }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For event handling, UI updates.&#10;&#10;**When not to use:**  &#10;&#10;- When only one object needs notification.&#10;&#10;---&#10;&#10;### State&#10;&#10;Alters behavior when internal state changes.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface State {&#10;    void handle();&#10;}&#10;&#10;public class Context {&#10;    private State state;&#10;    public Context(State state) { this.state = state; }&#10;    public void request() { state.handle(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When object behavior depends on state.&#10;&#10;**When not to use:**  &#10;&#10;- When state changes are rare.&#10;&#10;---&#10;&#10;### Strategy&#10;&#10;Encapsulates interchangeable algorithms.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Strategy {&#10;    int execute(int[] data);&#10;}&#10;&#10;public class SortStrategy implements Strategy {&#10;    public int execute(int[] data) {&#10;        java.util.Arrays.sort(data);&#10;        return data[0]; // Just for demonstration&#10;    }&#10;}&#10;&#10;public class Context {&#10;    private Strategy strategy;&#10;    public Context(Strategy strategy) { this.strategy = strategy; }&#10;    public int doTask(int[] data) { return strategy.execute(data); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When multiple algorithms are needed.&#10;&#10;**When not to use:**  &#10;&#10;- When only one algorithm is used.&#10;&#10;---&#10;&#10;### Template Method&#10;&#10;Defines the skeleton of an algorithm, deferring steps to subclasses.&#10;&#10;**Example (Java):**&#10;```java&#10;public abstract class AbstractClass {&#10;    public final void templateMethod() {&#10;        step1();&#10;        step2();&#10;    }&#10;    protected abstract void step1();&#10;    protected abstract void step2();&#10;}&#10;&#10;public class ConcreteClass extends AbstractClass {&#10;    protected void step1() { System.out.println(&quot;Step 1&quot;); }&#10;    protected void step2() { System.out.println(&quot;Step 2&quot;); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When algorithms have invariant steps.&#10;&#10;**When not to use:**  &#10;&#10;- When steps never change.&#10;&#10;---&#10;&#10;### Visitor&#10;&#10;Represents an operation to be performed on elements of an object structure.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Visitor {&#10;    void visit(Element element);&#10;}&#10;&#10;public interface Element {&#10;    void accept(Visitor visitor);&#10;}&#10;&#10;public class ConcreteElement implements Element {&#10;    public void accept(Visitor visitor) { visitor.visit(this); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to perform operations on object structures.&#10;&#10;**When not to use:**  &#10;&#10;- When object structure rarely changes.&#10;&#10;---&#10;&#10;## Summary&#10;&#10;The 23 core design patterns (Gang of Four) are essential tools for software engineers.  &#10;They provide proven solutions to common problems in software design, improve code maintainability, and are frequently discussed in interviews.  &#10;Understanding these patterns helps you write flexible, scalable, and robust code." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/content/posts/system_design/jee_design_patterns.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/content/posts/system_design/jee_design_patterns.md" />
              <option name="originalContent" value="+++&#10;date = '2024-05-03T12:44:47+10:00'&#10;draft = false&#10;title = 'JEE Design Patterns'&#10;tags = ['JEE Design Patterns', 'Interview']&#10;+++&#10;&#10;About JEE Design Patterns.&#10;&#10;## Table of Contents&#10;" />
              <option name="updatedContent" value="+++&#10;date = '2025-05-03T12:44:47+10:00'&#10;draft = false&#10;title = 'JEE Design Patterns'&#10;tags = ['JEE Design Patterns', 'Interview']&#10;+++&#10;&#10;JEE design patterns are specialized solutions for enterprise Java applications. They address scalability, maintainability, and performance challenges in distributed systems, helping developers build robust, modular, and efficient enterprise-grade software.&#10;&#10;## Table of Contents&#10;&#10;- [Presentation Tier Patterns](#presentation-tier-patterns)&#10;  - [Intercepting Filter](#intercepting-filter)&#10;  - [Front Controller](#front-controller)&#10;  - [View Helper](#view-helper)&#10;  - [Composite View](#composite-view)&#10;- [Business Tier Patterns](#business-tier-patterns)&#10;  - [Business Delegate](#business-delegate)&#10;  - [Session Facade](#session-facade)&#10;  - [Application Service](#application-service)&#10;  - [Service Locator](#service-locator)&#10;  - [Transfer Object](#transfer-object)&#10;- [Integration Tier Patterns](#integration-tier-patterns)&#10;  - [Data Access Object (DAO)](#data-access-object-dao)&#10;  - [Service Activator](#service-activator)&#10;  - [Web Service Broker](#web-service-broker)&#10;- [Summary](#summary)&#10;&#10;---&#10;&#10;## Presentation Tier Patterns&#10;&#10;### Intercepting Filter&#10;&#10;Provides centralized request pre-processing and post-processing.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Filter {&#10;    void execute(String request);&#10;}&#10;&#10;public class AuthenticationFilter implements Filter {&#10;    public void execute(String request) {&#10;        System.out.println(&quot;Authenticating request: &quot; + request);&#10;    }&#10;}&#10;&#10;public class FilterChain {&#10;    private List&lt;Filter&gt; filters = new ArrayList&lt;&gt;();&#10;    public void addFilter(Filter filter) { filters.add(filter); }&#10;    public void execute(String request) {&#10;        for (Filter filter : filters) { filter.execute(request); }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- When you need reusable request processing logic (logging, authentication).&#10;&#10;**When not to use:**  &#10;- When processing logic is simple or not reusable.&#10;&#10;---&#10;&#10;### Front Controller&#10;&#10;Centralizes request handling to improve control and flexibility.&#10;&#10;**Example (Java):**&#10;```java&#10;public class FrontController {&#10;    public void dispatchRequest(String request) {&#10;        if (&quot;HOME&quot;.equals(request)) {&#10;            System.out.println(&quot;Displaying Home Page&quot;);&#10;        } else {&#10;            System.out.println(&quot;404 Not Found&quot;);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- When you want a single entry point for requests.&#10;&#10;**When not to use:**  &#10;- For very simple applications.&#10;&#10;---&#10;&#10;### View Helper&#10;&#10;Separates business logic from view rendering.&#10;&#10;**Example (Java):**&#10;```java&#10;public class ViewHelper {&#10;    public String formatDate(Date date) {&#10;        return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(date);&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- When you want to keep views clean and reusable.&#10;&#10;**When not to use:**  &#10;- When formatting logic is trivial.&#10;&#10;---&#10;&#10;### Composite View&#10;&#10;Creates views from modular, reusable subviews.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface View {&#10;    void render();&#10;}&#10;&#10;public class HeaderView implements View {&#10;    public void render() { System.out.println(&quot;Header&quot;); }&#10;}&#10;&#10;public class CompositeView implements View {&#10;    private List&lt;View&gt; views = new ArrayList&lt;&gt;();&#10;    public void addView(View view) { views.add(view); }&#10;    public void render() {&#10;        for (View view : views) { view.render(); }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- For complex UIs with reusable components.&#10;&#10;**When not to use:**  &#10;- For simple, static views.&#10;&#10;---&#10;&#10;## Business Tier Patterns&#10;&#10;### Business Delegate&#10;&#10;Decouples presentation and business logic.&#10;&#10;**Example (Java):**&#10;```java&#10;public class BusinessService {&#10;    public void doTask() { System.out.println(&quot;Business logic executed&quot;); }&#10;}&#10;&#10;public class BusinessDelegate {&#10;    private BusinessService service = new BusinessService();&#10;    public void executeTask() { service.doTask(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- When you want to hide business logic complexity from the presentation tier.&#10;&#10;**When not to use:**  &#10;- When business logic is simple.&#10;&#10;---&#10;&#10;### Session Facade&#10;&#10;Provides a unified interface to a set of business services.&#10;&#10;**Example (Java):**&#10;```java&#10;public class OrderService { public void placeOrder() {} }&#10;public class PaymentService { public void processPayment() {} }&#10;&#10;public class SessionFacade {&#10;    private OrderService orderService = new OrderService();&#10;    private PaymentService paymentService = new PaymentService();&#10;    public void completeOrder() {&#10;        orderService.placeOrder();&#10;        paymentService.processPayment();&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- When you want to reduce network calls and simplify client interaction.&#10;&#10;**When not to use:**  &#10;- When only one service is involved.&#10;&#10;---&#10;&#10;### Application Service&#10;&#10;Coordinates business logic across multiple operations.&#10;&#10;**Example (Java):**&#10;```java&#10;public class ApplicationService {&#10;    public void performBusinessOperation() {&#10;        // Business logic spanning multiple domain objects&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- For complex business workflows.&#10;&#10;**When not to use:**  &#10;- For simple, single-step operations.&#10;&#10;---&#10;&#10;### Service Locator&#10;&#10;Centralizes service lookup and management.&#10;&#10;**Example (Java):**&#10;```java&#10;public class ServiceLocator {&#10;    private static Map&lt;String, Object&gt; services = new HashMap&lt;&gt;();&#10;    public static Object getService(String name) { return services.get(name); }&#10;    public static void registerService(String name, Object service) { services.put(name, service); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- When you need to decouple service consumers from service creation.&#10;&#10;**When not to use:**  &#10;- When dependency injection is preferred.&#10;&#10;---&#10;&#10;### Transfer Object&#10;&#10;Encapsulates data for transfer between layers.&#10;&#10;**Example (Java):**&#10;```java&#10;public class CustomerDTO {&#10;    private String name;&#10;    private String email;&#10;    // getters and setters&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- When transferring multiple data fields between layers.&#10;&#10;**When not to use:**  &#10;- For simple, single-field transfers.&#10;&#10;---&#10;&#10;## Integration Tier Patterns&#10;&#10;### Data Access Object (DAO)&#10;&#10;Abstracts and encapsulates all access to the data source.&#10;&#10;**Example (Java):**&#10;```java&#10;public class CustomerDAO {&#10;    public CustomerDTO findCustomerById(int id) {&#10;        // DB lookup logic&#10;        return new CustomerDTO();&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- When you want to separate persistence logic from business logic.&#10;&#10;**When not to use:**  &#10;- For trivial data access.&#10;&#10;---&#10;&#10;### Service Activator&#10;&#10;Enables asynchronous invocation of business services.&#10;&#10;**Example (Java):**&#10;```java&#10;public class ServiceActivator {&#10;    public void activateService(Runnable serviceTask) {&#10;        new Thread(serviceTask).start();&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- For asynchronous processing.&#10;&#10;**When not to use:**  &#10;- For synchronous, simple calls.&#10;&#10;---&#10;&#10;### Web Service Broker&#10;&#10;Centralizes and manages web service interactions.&#10;&#10;**Example (Java):**&#10;```java&#10;public class WebServiceBroker {&#10;    public void callService(String endpoint) {&#10;        System.out.println(&quot;Calling web service at &quot; + endpoint);&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- For integrating multiple web services.&#10;&#10;**When not to use:**  &#10;- For direct, simple web service calls.&#10;&#10;---&#10;&#10;## Summary&#10;&#10;JEE design patterns help solve common problems in enterprise Java applications.  &#10;They improve scalability, maintainability, and modularity, and are essential knowledge for interviews and building robust distributed systems." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/themes/gravionis/layouts/_partials/footer.html">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/themes/gravionis/layouts/_partials/footer.html" />
              <option name="originalContent" value="&lt;footer class=&quot;site-bar&quot; style=&quot;position: fixed; bottom: 0; left: 0; width: 100vw; height: 48px; display: flex; align-items: center; justify-content: center; padding: 0 2rem; z-index: 200;&quot;&gt;&#10;  &lt;p style=&quot;margin: 0; font-size: 1rem;&quot;&gt;Copyright {{ now.Year }}. All rights reserved.&lt;/p&gt;&#10;&lt;/footer&gt;&#10;&#10;&lt;!-- Modal Structure --&gt;&#10;&lt;div id=&quot;imageModal&quot; style=&quot;display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); z-index: 1000; justify-content: center; align-items: center;&quot;&gt;&#10;  &lt;span id=&quot;closeModal&quot; style=&quot;position: absolute; top: 20px; right: 30px; font-size: 30px; color: white; cursor: pointer;&quot;&gt;&amp;times;&lt;/span&gt;&#10;  &lt;img id=&quot;modalImage&quot; src=&quot;&quot; alt=&quot;&quot; style=&quot;max-width: 100%; max-height: 100%;&quot;&gt;&#10;&lt;/div&gt;&#10;&#10;&lt;script&gt;&#10;  document.addEventListener('DOMContentLoaded', function() {&#10;    const modal = document.getElementById('imageModal');&#10;    const modalImage = document.getElementById('modalImage');&#10;    const closeModal = document.getElementById('closeModal');&#10;&#10;    document.querySelectorAll('img').forEach(img =&gt; {&#10;      img.addEventListener('click', () =&gt; {&#10;        modalImage.src = img.src;&#10;        modal.style.display = 'flex';&#10;      });&#10;    });&#10;&#10;    closeModal.addEventListener('click', () =&gt; {&#10;      modal.style.display = 'none';&#10;    });&#10;&#10;    modal.addEventListener('click', (e) =&gt; {&#10;      if (e.target === modal) {&#10;        modal.style.display = 'none';&#10;      }&#10;    });&#10;  });&#10;&lt;/script&gt;&#10;" />
              <option name="updatedContent" value="&lt;!-- Footer removed as per request --&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/themes/gravionis/layouts/_partials/header.html">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/themes/gravionis/layouts/_partials/header.html" />
              <option name="originalContent" value="&lt;div id=&quot;main-header&quot; class=&quot;site-bar&quot; style=&quot;position: fixed; top: 0; left: 0; width: 100vw; height: 64px; z-index: 201; display: flex; flex-direction: row; align-items: center; padding: 0 2rem;&quot;&gt;&#10;  &lt;h1 style=&quot;margin: 0 2rem 0 0; font-size: 1.5rem; color: #fff;&quot;&gt;{{ site.Title }}&lt;/h1&gt;&#10;  &lt;nav style=&quot;height: 100%; display: flex; align-items: center; margin-left: auto; margin-right: 8vw;&quot;&gt;&#10;    {{ partial &quot;menu.html&quot; (dict &quot;menuID&quot; &quot;main&quot; &quot;page&quot; .) }}&#10;  &lt;/nav&gt;&#10;&lt;/div&gt;&#10;&lt;style&gt;&#10;  .site-bar {&#10;    background: #222;&#10;    color: #fff;&#10;    box-shadow: 0 2px 8px 2px #0078ff, 0 0 8px 2px #222;&#10;    transition: box-shadow 0.3s;&#10;  }&#10;  .site-bar a, .site-bar h1 {&#10;    color: #fff !important;&#10;  }&#10;  .site-bar:hover {&#10;    box-shadow: 0 0 24px 6px #0078ff, 0 0 12px 4px #222;&#10;    transition: box-shadow 0.3s;&#10;  }&#10;  body {&#10;    margin-top: 64px;&#10;    margin-left: 5vw;&#10;    margin-right: 0;&#10;    width: 100%;&#10;    font-size: 0.95rem;&#10;    background: #f0f0f0;&#10;  }&#10;  @media (max-width: 600px) {&#10;    body {&#10;      margin-top: 56px;&#10;      margin-left: 1rem;&#10;      margin-right: 0;&#10;      width: 100%;&#10;      font-size: 1rem;&#10;      background: #f0f0f0;&#10;    }&#10;    .top-menu {&#10;      display: none;&#10;    }&#10;  }&#10;  .menu-glow:hover {&#10;    box-shadow: 0 0 8px 2px #0078ff, 0 0 2px 1px #222;&#10;    color: #0078ff !important;&#10;    transition: box-shadow 0.2s, background 0.2s, color 0.2s;&#10;  }&#10;&lt;/style&gt;&#10;" />
              <option name="updatedContent" value="&lt;div id=&quot;main-header&quot; class=&quot;site-bar&quot; style=&quot;position: fixed; top: 0; left: 0; width: 100%; height: 64px; z-index: 201; display: flex; flex-direction: row; align-items: center; padding: 0 2rem;&quot;&gt;&#10;  &lt;h1 style=&quot;margin: 0 2rem 0 0; font-size: 1.5rem; color: #fff;&quot;&gt;{{ site.Title }}&lt;/h1&gt;&#10;  &lt;nav style=&quot;height: 100%; display: flex; align-items: center; margin-left: auto; margin-right: 8vw;&quot;&gt;&#10;    {{ partial &quot;menu.html&quot; (dict &quot;menuID&quot; &quot;main&quot; &quot;page&quot; .) }}&#10;  &lt;/nav&gt;&#10;&lt;/div&gt;&#10;&lt;style&gt;&#10;  .site-bar {&#10;    background: #222;&#10;    color: #fff;&#10;    box-shadow: 0 2px 8px 2px #0078ff, 0 0 8px 2px #222;&#10;    transition: box-shadow 0.3s;&#10;  }&#10;  .site-bar a, .site-bar h1 {&#10;    color: #fff !important;&#10;  }&#10;  .site-bar:hover {&#10;    box-shadow: 0 0 24px 6px #0078ff, 0 0 12px 4px #222;&#10;    transition: box-shadow 0.3s;&#10;  }&#10;  body {&#10;    margin-top: 64px;&#10;    margin-left: 5vw;&#10;    margin-right: 0;&#10;    width: 100%;&#10;    font-size: 0.95rem;&#10;    background: #f0f0f0;&#10;    overflow-x: hidden;&#10;  }&#10;  @media (max-width: 600px) {&#10;    body {&#10;      margin-top: 56px;&#10;      margin-left: 1rem;&#10;      margin-right: 0;&#10;      width: 100%;&#10;      font-size: 1rem;&#10;      background: #f0f0f0;&#10;    }&#10;    .top-menu {&#10;      display: none;&#10;    }&#10;  }&#10;  .menu-glow:hover {&#10;    box-shadow: 0 0 8px 2px #0078ff, 0 0 2px 1px #222;&#10;    color: #0078ff !important;&#10;    transition: box-shadow 0.2s, background 0.2s, color 0.2s;&#10;  }&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/themes/gravionis/layouts/section.html">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/themes/gravionis/layouts/section.html" />
              <option name="originalContent" value="{{ define &quot;main&quot; }}&#10;  &lt;h1&gt;{{ .Title }}&lt;/h1&gt;&#10;  {{ .Content }}&#10;  &lt;style&gt;&#10;    .post-card {&#10;      border: 1px solid #ccc;&#10;      padding: 15px;&#10;      margin: 10px 0;&#10;      border-radius: 12px;&#10;      box-shadow: 0 2px 8px 2px #0078ff22, 0 0 8px 2px #fff2;&#10;      transition: box-shadow 0.3s, border-color 0.3s;&#10;      background: #fff;&#10;    }&#10;    .post-card:hover {&#10;      box-shadow: 0 0 24px 6px #0078ff88, 0 0 12px 4px #fff;&#10;      border-color: #0078ff;&#10;      background: #f0f8ff;&#10;    }&#10;    .post-card h2 a {&#10;      text-decoration: none;&#10;      color: #0078ff;&#10;      transition: color 0.2s;&#10;    }&#10;    .post-card:hover h2 a {&#10;      color: #0050bb;&#10;    }&#10;  &lt;/style&gt;&#10;  {{ range .Pages }}&#10;    &lt;div class=&quot;post-card&quot;&gt;&#10;      &lt;h2&gt;&lt;a href=&quot;{{ .RelPermalink }}&quot;&gt;{{ .LinkTitle }}&lt;/a&gt;&lt;/h2&gt;&#10;      {{ .Summary | truncate 250 }}&#10;    &lt;/div&gt;&#10;  {{ end }}&#10;{{ end }}&#10;" />
              <option name="updatedContent" value="{{ define &quot;main&quot; }}&#10;  &lt;h1&gt;{{ .Title }}&lt;/h1&gt;&#10;  {{ .Content }}&#10;  &lt;style&gt;&#10;    .post-card-link {&#10;      text-decoration: none;&#10;      color: inherit;&#10;      display: block;&#10;    }&#10;    .post-card {&#10;      border: 1px solid #ccc;&#10;      padding: 15px;&#10;      margin: 10px 0;&#10;      border-radius: 12px;&#10;      box-shadow: 0 2px 8px 2px #0078ff22, 0 0 8px 2px #fff2;&#10;      transition: box-shadow 0.3s, border-color 0.3s;&#10;      background: #fff;&#10;      cursor: pointer;&#10;    }&#10;    .post-card:hover {&#10;      box-shadow: 0 0 24px 6px #0078ff88, 0 0 12px 4px #fff;&#10;      border-color: #0078ff;&#10;      background: #f0f8ff;&#10;    }&#10;    .post-card h2 a {&#10;      text-decoration: none;&#10;      color: #0078ff;&#10;      transition: color 0.2s;&#10;    }&#10;    .post-card:hover h2 a {&#10;      color: #0050bb;&#10;    }&#10;  &lt;/style&gt;&#10;  {{ range .Pages }}&#10;    &lt;a class=&quot;post-card-link&quot; href=&quot;{{ .RelPermalink }}&quot;&gt;&#10;      &lt;div class=&quot;post-card&quot;&gt;&#10;        &lt;h2&gt;{{ .LinkTitle }}&lt;/h2&gt;&#10;        {{ .Summary | truncate 250 }}&#10;      &lt;/div&gt;&#10;    &lt;/a&gt;&#10;  {{ end }}&#10;{{ end }}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>