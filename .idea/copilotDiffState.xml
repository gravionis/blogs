<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/content/posts/system_design/core_design_patterns.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/content/posts/system_design/core_design_patterns.md" />
              <option name="originalContent" value="+++&#10;date = '2024-05-03T12:44:47+10:00'&#10;draft = false&#10;title = '23 Core Design Patterns'&#10;tags = ['Core Design Patterns', 'Interview']&#10;+++&#10;&#10;About Core Design Patterns.&#10;&#10;## Table of Contents&#10;&#10;- [Creational Patterns](#creational-patterns)&#10;  - [Singleton](#singleton)&#10;  - [Factory Method](#factory-method)&#10;  - [Abstract Factory](#abstract-factory)&#10;  - [Builder](#builder)&#10;  - [Prototype](#prototype)&#10;- [Structural Patterns](#structural-patterns)&#10;  - [Adapter](#adapter)&#10;  - [Bridge](#bridge)&#10;  - [Composite](#composite)&#10;  - [Decorator](#decorator)&#10;  - [Facade](#facade)&#10;  - [Flyweight](#flyweight)&#10;  - [Proxy](#proxy)&#10;- [Behavioral Patterns](#behavioral-patterns)&#10;  - [Chain of Responsibility](#chain-of-responsibility)&#10;  - [Command](#command)&#10;  - [Interpreter](#interpreter)&#10;  - [Iterator](#iterator)&#10;  - [Mediator](#mediator)&#10;  - [Memento](#memento)&#10;  - [Observer](#observer)&#10;  - [State](#state)&#10;  - [Strategy](#strategy)&#10;  - [Template Method](#template-method)&#10;  - [Visitor](#visitor)&#10;- [Summary](#summary)&#10;&#10;---&#10;&#10;## Creational Patterns&#10;&#10;### Singleton&#10;&#10;Ensures a class has only one instance and provides a global point of access to it.&#10;&#10;**Example (Java):**&#10;```java&#10;public class Singleton {&#10;    private static Singleton uniqueInstance;&#10;    private Singleton() {}&#10;    public static synchronized Singleton getInstance() {&#10;        if (uniqueInstance == null) {&#10;            uniqueInstance = new Singleton();&#10;        }&#10;        return uniqueInstance;&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need a single shared resource (e.g., config, logger, cache).&#10;&#10;**When not to use:**  &#10;&#10;- When you need multiple instances (e.g., for testing, parallelism).&#10;- Can introduce hidden dependencies and global state.&#10;&#10;---&#10;&#10;### Factory Method&#10;&#10;Defines an interface for creating an object, but lets subclasses decide which class to instantiate.&#10;&#10;**Example (Java):**&#10;```java&#10;public abstract class Animal {&#10;    public abstract String speak();&#10;}&#10;&#10;public class Dog extends Animal {&#10;    public String speak() { return &quot;Woof!&quot;; }&#10;}&#10;&#10;public class Cat extends Animal {&#10;    public String speak() { return &quot;Meow!&quot;; }&#10;}&#10;&#10;public abstract class AnimalFactory {&#10;    public abstract Animal createAnimal();&#10;}&#10;&#10;public class DogFactory extends AnimalFactory {&#10;    public Animal createAnimal() { return new Dog(); }&#10;}&#10;&#10;public class CatFactory extends AnimalFactory {&#10;    public Animal createAnimal() { return new Cat(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When a class can't anticipate the type of objects it needs to create.&#10;&#10;**When not to use:**  &#10;&#10;- When object creation is simple and doesn't need abstraction.&#10;&#10;---&#10;&#10;### Abstract Factory&#10;&#10;Provides an interface for creating families of related or dependent objects without specifying their concrete classes.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Button {&#10;    void paint();&#10;}&#10;&#10;public class WinButton implements Button {&#10;    public void paint() { System.out.println(&quot;Windows Button&quot;); }&#10;}&#10;&#10;public class MacButton implements Button {&#10;    public void paint() { System.out.println(&quot;Mac Button&quot;); }&#10;}&#10;&#10;public interface GUIFactory {&#10;    Button createButton();&#10;}&#10;&#10;public class WinFactory implements GUIFactory {&#10;    public Button createButton() { return new WinButton(); }&#10;}&#10;&#10;public class MacFactory implements GUIFactory {&#10;    public Button createButton() { return new MacButton(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to create families of related objects.&#10;&#10;**When not to use:**  &#10;&#10;- When products don't need to be related.&#10;&#10;---&#10;&#10;### Builder&#10;&#10;Separates the construction of a complex object from its representation.&#10;&#10;**Example (Java):**&#10;```java&#10;public class Burger {&#10;    private boolean cheese;&#10;    private boolean lettuce;&#10;&#10;    public static class Builder {&#10;        private boolean cheese;&#10;        private boolean lettuce;&#10;&#10;        public Builder addCheese() {&#10;            cheese = true;&#10;            return this;&#10;        }&#10;        public Builder addLettuce() {&#10;            lettuce = true;&#10;            return this;&#10;        }&#10;        public Burger build() {&#10;            Burger burger = new Burger();&#10;            burger.cheese = this.cheese;&#10;            burger.lettuce = this.lettuce;&#10;            return burger;&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When constructing complex objects step by step.&#10;&#10;**When not to use:**  &#10;&#10;- For simple objects with few parameters.&#10;&#10;---&#10;&#10;### Prototype&#10;&#10;Creates new objects by copying an existing object.&#10;&#10;**Example (Java):**&#10;```java&#10;public abstract class Prototype implements Cloneable {&#10;    public Prototype clone() {&#10;        try {&#10;            return (Prototype) super.clone();&#10;        } catch (CloneNotSupportedException e) {&#10;            throw new AssertionError();&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When object creation is costly and similar objects are needed.&#10;&#10;**When not to use:**  &#10;&#10;- When objects are simple or copying is not needed.&#10;&#10;---&#10;&#10;## Structural Patterns&#10;&#10;### Adapter&#10;&#10;Allows incompatible interfaces to work together.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface USASocket {&#10;    int voltage();&#10;}&#10;&#10;public class EuropeanSocket {&#10;    public int voltage() { return 230; }&#10;}&#10;&#10;public class SocketAdapter implements USASocket {&#10;    private EuropeanSocket europeanSocket;&#10;    public SocketAdapter(EuropeanSocket socket) {&#10;        this.europeanSocket = socket;&#10;    }&#10;    public int voltage() {&#10;        return europeanSocket.voltage();&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When integrating with legacy or third-party code.&#10;&#10;**When not to use:**  &#10;&#10;- When you can refactor code directly.&#10;&#10;---&#10;&#10;### Bridge&#10;&#10;Separates abstraction from implementation.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface DrawingAPI {&#10;    void drawCircle(int x, int y, int r);&#10;}&#10;&#10;public class DrawingAPI1 implements DrawingAPI {&#10;    public void drawCircle(int x, int y, int r) {&#10;        System.out.println(&quot;API1: Circle at &quot; + x + &quot;,&quot; + y + &quot; radius &quot; + r);&#10;    }&#10;}&#10;&#10;public abstract class Shape {&#10;    protected DrawingAPI api;&#10;    public Shape(DrawingAPI api) { this.api = api; }&#10;    public abstract void draw();&#10;}&#10;&#10;public class Circle extends Shape {&#10;    private int x, y, r;&#10;    public Circle(int x, int y, int r, DrawingAPI api) {&#10;        super(api);&#10;        this.x = x; this.y = y; this.r = r;&#10;    }&#10;    public void draw() { api.drawCircle(x, y, r); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When abstraction and implementation should vary independently.&#10;&#10;**When not to use:**  &#10;&#10;- When only one implementation is needed.&#10;&#10;---&#10;&#10;### Composite&#10;&#10;Composes objects into tree structures.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Component {&#10;    void operation();&#10;}&#10;&#10;public class Leaf implements Component {&#10;    public void operation() { System.out.println(&quot;Leaf&quot;); }&#10;}&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class Composite implements Component {&#10;    private List&lt;Component&gt; children = new ArrayList&lt;&gt;();&#10;    public void add(Component component) { children.add(component); }&#10;    public void operation() {&#10;        for (Component child : children) {&#10;            child.operation();&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to treat individual and composite objects uniformly.&#10;&#10;**When not to use:**  &#10;&#10;- When hierarchy is not needed.&#10;&#10;---&#10;&#10;### Decorator&#10;&#10;Adds new functionality to an object dynamically.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Coffee {&#10;    int cost();&#10;}&#10;&#10;public class SimpleCoffee implements Coffee {&#10;    public int cost() { return 5; }&#10;}&#10;&#10;public class MilkDecorator implements Coffee {&#10;    private Coffee coffee;&#10;    public MilkDecorator(Coffee coffee) { this.coffee = coffee; }&#10;    public int cost() { return coffee.cost() + 2; }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to add responsibilities to objects dynamically.&#10;&#10;**When not to use:**  &#10;&#10;- When subclassing is simpler.&#10;&#10;---&#10;&#10;### Facade&#10;&#10;Provides a simplified interface to a complex subsystem.&#10;&#10;**Example (Java):**&#10;```java&#10;public class CPU { public void freeze() {} }&#10;public class Memory { public void load(int pos, String data) {} }&#10;&#10;public class ComputerFacade {&#10;    private CPU cpu;&#10;    private Memory memory;&#10;    public ComputerFacade() {&#10;        cpu = new CPU();&#10;        memory = new Memory();&#10;    }&#10;    public void start() {&#10;        cpu.freeze();&#10;        memory.load(0, &quot;data&quot;);&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you want to provide a simple interface to a complex system.&#10;&#10;**When not to use:**  &#10;&#10;- When subsystem is already simple.&#10;&#10;---&#10;&#10;### Flyweight&#10;&#10;Reduces memory usage by sharing data.&#10;&#10;**Example (Java):**&#10;```java&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class Flyweight {&#10;    private String shared;&#10;    public Flyweight(String shared) { this.shared = shared; }&#10;}&#10;&#10;public class FlyweightFactory {&#10;    private Map&lt;String, Flyweight&gt; flyweights = new HashMap&lt;&gt;();&#10;    public Flyweight getFlyweight(String shared) {&#10;        if (!flyweights.containsKey(shared)) {&#10;            flyweights.put(shared, new Flyweight(shared));&#10;        }&#10;        return flyweights.get(shared);&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When many objects share common data.&#10;&#10;**When not to use:**  &#10;&#10;- When objects are unique.&#10;&#10;---&#10;&#10;### Proxy&#10;&#10;Provides a surrogate for another object.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Subject {&#10;    void request();&#10;}&#10;&#10;public class RealSubject implements Subject {&#10;    public void request() { System.out.println(&quot;RealSubject&quot;); }&#10;}&#10;&#10;public class Proxy implements Subject {&#10;    private RealSubject real;&#10;    public Proxy(RealSubject real) { this.real = real; }&#10;    public void request() {&#10;        System.out.println(&quot;Proxy: Checking access&quot;);&#10;        real.request();&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For access control, lazy loading, logging.&#10;&#10;**When not to use:**  &#10;&#10;- When direct access is acceptable.&#10;&#10;---&#10;&#10;## Behavioral Patterns&#10;&#10;### Chain of Responsibility&#10;&#10;Passes a request along a chain of handlers.&#10;&#10;**Example (Java):**&#10;```java&#10;public abstract class Handler {&#10;    protected Handler next;&#10;    public void setNext(Handler next) { this.next = next; }&#10;    public void handle(String request) {&#10;        if (next != null) next.handle(request);&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When multiple objects can handle a request.&#10;&#10;**When not to use:**  &#10;&#10;- When only one handler is needed.&#10;&#10;---&#10;&#10;### Command&#10;&#10;Encapsulates a request as an object.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Command {&#10;    void execute();&#10;}&#10;&#10;public class LightOnCommand implements Command {&#10;    public void execute() { System.out.println(&quot;Light On&quot;); }&#10;}&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class Remote {&#10;    private List&lt;Command&gt; commands = new ArrayList&lt;&gt;();&#10;    public void addCommand(Command cmd) { commands.add(cmd); }&#10;    public void run() {&#10;        for (Command cmd : commands) { cmd.execute(); }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For undo/redo, queuing, logging.&#10;&#10;**When not to use:**  &#10;&#10;- When simple method calls suffice.&#10;&#10;---&#10;&#10;### Interpreter&#10;&#10;Defines a grammar and provides an interpreter.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Expression {&#10;    int interpret();&#10;}&#10;&#10;public class Number implements Expression {&#10;    private int value;&#10;    public Number(int value) { this.value = value; }&#10;    public int interpret() { return value; }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For languages, expressions, parsing.&#10;&#10;**When not to use:**  &#10;&#10;- For simple or infrequent grammar.&#10;&#10;---&#10;&#10;### Iterator&#10;&#10;Provides a way to access elements sequentially.&#10;&#10;**Example (Java):**&#10;```java&#10;import java.util.Iterator;&#10;import java.util.List;&#10;&#10;public class MyIterator implements Iterator&lt;String&gt; {&#10;    private List&lt;String&gt; collection;&#10;    private int index = 0;&#10;    public MyIterator(List&lt;String&gt; collection) { this.collection = collection; }&#10;    public boolean hasNext() { return index &lt; collection.size(); }&#10;    public String next() { return collection.get(index++); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to traverse a collection.&#10;&#10;**When not to use:**  &#10;&#10;- When direct access is sufficient.&#10;&#10;---&#10;&#10;### Mediator&#10;&#10;Encapsulates how objects interact.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Mediator {&#10;    void notify(Component sender, String event);&#10;}&#10;&#10;public class Component {&#10;    private Mediator mediator;&#10;    public Component(Mediator mediator) { this.mediator = mediator; }&#10;    public void doSomething() { mediator.notify(this, &quot;event&quot;); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When objects communicate in complex ways.&#10;&#10;**When not to use:**  &#10;&#10;- When communication is simple.&#10;&#10;---&#10;&#10;### Memento&#10;&#10;Captures and restores an object's state.&#10;&#10;**Example (Java):**&#10;```java&#10;public class Memento {&#10;    private String state;&#10;    public Memento(String state) { this.state = state; }&#10;    public String getState() { return state; }&#10;}&#10;&#10;public class Originator {&#10;    private String state;&#10;    public void setState(String state) { this.state = state; }&#10;    public Memento save() { return new Memento(state); }&#10;    public void restore(Memento memento) { state = memento.getState(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For undo/redo functionality.&#10;&#10;**When not to use:**  &#10;&#10;- When state is simple or not needed.&#10;&#10;---&#10;&#10;### Observer&#10;&#10;One-to-many dependency so dependents are notified of changes.&#10;&#10;**Example (Java):**&#10;```java&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public interface Observer {&#10;    void update();&#10;}&#10;&#10;public class Subject {&#10;    private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();&#10;    public void attach(Observer obs) { observers.add(obs); }&#10;    public void notifyObservers() {&#10;        for (Observer obs : observers) { obs.update(); }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For event handling, UI updates.&#10;&#10;**When not to use:**  &#10;&#10;- When only one object needs notification.&#10;&#10;---&#10;&#10;### State&#10;&#10;Alters behavior when internal state changes.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface State {&#10;    void handle();&#10;}&#10;&#10;public class Context {&#10;    private State state;&#10;    public Context(State state) { this.state = state; }&#10;    public void request() { state.handle(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When object behavior depends on state.&#10;&#10;**When not to use:**  &#10;&#10;- When state changes are rare.&#10;&#10;---&#10;&#10;### Strategy&#10;&#10;Encapsulates interchangeable algorithms.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Strategy {&#10;    int execute(int[] data);&#10;}&#10;&#10;public class SortStrategy implements Strategy {&#10;    public int execute(int[] data) {&#10;        java.util.Arrays.sort(data);&#10;        return data[0]; // Just for demonstration&#10;    }&#10;}&#10;&#10;public class Context {&#10;    private Strategy strategy;&#10;    public Context(Strategy strategy) { this.strategy = strategy; }&#10;    public int doTask(int[] data) { return strategy.execute(data); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When multiple algorithms are needed.&#10;&#10;**When not to use:**  &#10;&#10;- When only one algorithm is used.&#10;&#10;---&#10;&#10;### Template Method&#10;&#10;Defines the skeleton of an algorithm, deferring steps to subclasses.&#10;&#10;**Example (Java):**&#10;```java&#10;public abstract class AbstractClass {&#10;    public final void templateMethod() {&#10;        step1();&#10;        step2();&#10;    }&#10;    protected abstract void step1();&#10;    protected abstract void step2();&#10;}&#10;&#10;public class ConcreteClass extends AbstractClass {&#10;    protected void step1() { System.out.println(&quot;Step 1&quot;); }&#10;    protected void step2() { System.out.println(&quot;Step 2&quot;); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When algorithms have invariant steps.&#10;&#10;**When not to use:**  &#10;&#10;- When steps never change.&#10;&#10;---&#10;&#10;### Visitor&#10;&#10;Represents an operation to be performed on elements of an object structure.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Visitor {&#10;    void visit(Element element);&#10;}&#10;&#10;public interface Element {&#10;    void accept(Visitor visitor);&#10;}&#10;&#10;public class ConcreteElement implements Element {&#10;    public void accept(Visitor visitor) { visitor.visit(this); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to perform operations on object structures.&#10;&#10;**When not to use:**  &#10;&#10;- When object structure rarely changes.&#10;&#10;---&#10;&#10;## Summary&#10;&#10;The 23 core design patterns (Gang of Four) are essential tools for software engineers.  &#10;They provide proven solutions to common problems in software design, improve code maintainability, and are frequently discussed in interviews.  &#10;Understanding these patterns helps you write flexible, scalable, and robust code.&#10;" />
              <option name="updatedContent" value="+++&#10;date = '2025-05-03T12:44:47+10:00'&#10;draft = false&#10;title = '23 Core Design Patterns'&#10;tags = ['Core Design Patterns', 'Interview']&#10;+++&#10;&#10;Core design patterns are proven solutions to common software engineering problems. They help structure code for flexibility, scalability, and maintainability. Mastering these patterns is essential for interviews and for building robust, reusable, and understandable software systems.&#10;&#10;## Table of Contents&#10;&#10;- [Creational Patterns](#creational-patterns)&#10;  - [Singleton](#singleton)&#10;  - [Factory Method](#factory-method)&#10;  - [Abstract Factory](#abstract-factory)&#10;  - [Builder](#builder)&#10;  - [Prototype](#prototype)&#10;- [Structural Patterns](#structural-patterns)&#10;  - [Adapter](#adapter)&#10;  - [Bridge](#bridge)&#10;  - [Composite](#composite)&#10;  - [Decorator](#decorator)&#10;  - [Facade](#facade)&#10;  - [Flyweight](#flyweight)&#10;  - [Proxy](#proxy)&#10;- [Behavioral Patterns](#behavioral-patterns)&#10;  - [Chain of Responsibility](#chain-of-responsibility)&#10;  - [Command](#command)&#10;  - [Interpreter](#interpreter)&#10;  - [Iterator](#iterator)&#10;  - [Mediator](#mediator)&#10;  - [Memento](#memento)&#10;  - [Observer](#observer)&#10;  - [State](#state)&#10;  - [Strategy](#strategy)&#10;  - [Template Method](#template-method)&#10;  - [Visitor](#visitor)&#10;- [Summary](#summary)&#10;&#10;---&#10;&#10;## Creational Patterns&#10;&#10;### Singleton&#10;&#10;Ensures a class has only one instance and provides a global point of access to it.&#10;&#10;**Example (Java):**&#10;```java&#10;public class Singleton {&#10;    private static Singleton uniqueInstance;&#10;    private Singleton() {}&#10;    public static synchronized Singleton getInstance() {&#10;        if (uniqueInstance == null) {&#10;            uniqueInstance = new Singleton();&#10;        }&#10;        return uniqueInstance;&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need a single shared resource (e.g., config, logger, cache).&#10;&#10;**When not to use:**  &#10;&#10;- When you need multiple instances (e.g., for testing, parallelism).&#10;- Can introduce hidden dependencies and global state.&#10;&#10;---&#10;&#10;### Factory Method&#10;&#10;Defines an interface for creating an object, but lets subclasses decide which class to instantiate.&#10;&#10;**Example (Java):**&#10;```java&#10;public abstract class Animal {&#10;    public abstract String speak();&#10;}&#10;&#10;public class Dog extends Animal {&#10;    public String speak() { return &quot;Woof!&quot;; }&#10;}&#10;&#10;public class Cat extends Animal {&#10;    public String speak() { return &quot;Meow!&quot;; }&#10;}&#10;&#10;public abstract class AnimalFactory {&#10;    public abstract Animal createAnimal();&#10;}&#10;&#10;public class DogFactory extends AnimalFactory {&#10;    public Animal createAnimal() { return new Dog(); }&#10;}&#10;&#10;public class CatFactory extends AnimalFactory {&#10;    public Animal createAnimal() { return new Cat(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When a class can't anticipate the type of objects it needs to create.&#10;&#10;**When not to use:**  &#10;&#10;- When object creation is simple and doesn't need abstraction.&#10;&#10;---&#10;&#10;### Abstract Factory&#10;&#10;Provides an interface for creating families of related or dependent objects without specifying their concrete classes.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Button {&#10;    void paint();&#10;}&#10;&#10;public class WinButton implements Button {&#10;    public void paint() { System.out.println(&quot;Windows Button&quot;); }&#10;}&#10;&#10;public class MacButton implements Button {&#10;    public void paint() { System.out.println(&quot;Mac Button&quot;); }&#10;}&#10;&#10;public interface GUIFactory {&#10;    Button createButton();&#10;}&#10;&#10;public class WinFactory implements GUIFactory {&#10;    public Button createButton() { return new WinButton(); }&#10;}&#10;&#10;public class MacFactory implements GUIFactory {&#10;    public Button createButton() { return new MacButton(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to create families of related objects.&#10;&#10;**When not to use:**  &#10;&#10;- When products don't need to be related.&#10;&#10;---&#10;&#10;### Builder&#10;&#10;Separates the construction of a complex object from its representation.&#10;&#10;**Example (Java):**&#10;```java&#10;public class Burger {&#10;    private boolean cheese;&#10;    private boolean lettuce;&#10;&#10;    public static class Builder {&#10;        private boolean cheese;&#10;        private boolean lettuce;&#10;&#10;        public Builder addCheese() {&#10;            cheese = true;&#10;            return this;&#10;        }&#10;        public Builder addLettuce() {&#10;            lettuce = true;&#10;            return this;&#10;        }&#10;        public Burger build() {&#10;            Burger burger = new Burger();&#10;            burger.cheese = this.cheese;&#10;            burger.lettuce = this.lettuce;&#10;            return burger;&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When constructing complex objects step by step.&#10;&#10;**When not to use:**  &#10;&#10;- For simple objects with few parameters.&#10;&#10;---&#10;&#10;### Prototype&#10;&#10;Creates new objects by copying an existing object.&#10;&#10;**Example (Java):**&#10;```java&#10;public abstract class Prototype implements Cloneable {&#10;    public Prototype clone() {&#10;        try {&#10;            return (Prototype) super.clone();&#10;        } catch (CloneNotSupportedException e) {&#10;            throw new AssertionError();&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When object creation is costly and similar objects are needed.&#10;&#10;**When not to use:**  &#10;&#10;- When objects are simple or copying is not needed.&#10;&#10;---&#10;&#10;## Structural Patterns&#10;&#10;### Adapter&#10;&#10;Allows incompatible interfaces to work together.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface USASocket {&#10;    int voltage();&#10;}&#10;&#10;public class EuropeanSocket {&#10;    public int voltage() { return 230; }&#10;}&#10;&#10;public class SocketAdapter implements USASocket {&#10;    private EuropeanSocket europeanSocket;&#10;    public SocketAdapter(EuropeanSocket socket) {&#10;        this.europeanSocket = socket;&#10;    }&#10;    public int voltage() {&#10;        return europeanSocket.voltage();&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When integrating with legacy or third-party code.&#10;&#10;**When not to use:**  &#10;&#10;- When you can refactor code directly.&#10;&#10;---&#10;&#10;### Bridge&#10;&#10;Separates abstraction from implementation.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface DrawingAPI {&#10;    void drawCircle(int x, int y, int r);&#10;}&#10;&#10;public class DrawingAPI1 implements DrawingAPI {&#10;    public void drawCircle(int x, int y, int r) {&#10;        System.out.println(&quot;API1: Circle at &quot; + x + &quot;,&quot; + y + &quot; radius &quot; + r);&#10;    }&#10;}&#10;&#10;public abstract class Shape {&#10;    protected DrawingAPI api;&#10;    public Shape(DrawingAPI api) { this.api = api; }&#10;    public abstract void draw();&#10;}&#10;&#10;public class Circle extends Shape {&#10;    private int x, y, r;&#10;    public Circle(int x, int y, int r, DrawingAPI api) {&#10;        super(api);&#10;        this.x = x; this.y = y; this.r = r;&#10;    }&#10;    public void draw() { api.drawCircle(x, y, r); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When abstraction and implementation should vary independently.&#10;&#10;**When not to use:**  &#10;&#10;- When only one implementation is needed.&#10;&#10;---&#10;&#10;### Composite&#10;&#10;Composes objects into tree structures.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Component {&#10;    void operation();&#10;}&#10;&#10;public class Leaf implements Component {&#10;    public void operation() { System.out.println(&quot;Leaf&quot;); }&#10;}&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class Composite implements Component {&#10;    private List&lt;Component&gt; children = new ArrayList&lt;&gt;();&#10;    public void add(Component component) { children.add(component); }&#10;    public void operation() {&#10;        for (Component child : children) {&#10;            child.operation();&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to treat individual and composite objects uniformly.&#10;&#10;**When not to use:**  &#10;&#10;- When hierarchy is not needed.&#10;&#10;---&#10;&#10;### Decorator&#10;&#10;Adds new functionality to an object dynamically.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Coffee {&#10;    int cost();&#10;}&#10;&#10;public class SimpleCoffee implements Coffee {&#10;    public int cost() { return 5; }&#10;}&#10;&#10;public class MilkDecorator implements Coffee {&#10;    private Coffee coffee;&#10;    public MilkDecorator(Coffee coffee) { this.coffee = coffee; }&#10;    public int cost() { return coffee.cost() + 2; }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to add responsibilities to objects dynamically.&#10;&#10;**When not to use:**  &#10;&#10;- When subclassing is simpler.&#10;&#10;---&#10;&#10;### Facade&#10;&#10;Provides a simplified interface to a complex subsystem.&#10;&#10;**Example (Java):**&#10;```java&#10;public class CPU { public void freeze() {} }&#10;public class Memory { public void load(int pos, String data) {} }&#10;&#10;public class ComputerFacade {&#10;    private CPU cpu;&#10;    private Memory memory;&#10;    public ComputerFacade() {&#10;        cpu = new CPU();&#10;        memory = new Memory();&#10;    }&#10;    public void start() {&#10;        cpu.freeze();&#10;        memory.load(0, &quot;data&quot;);&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you want to provide a simple interface to a complex system.&#10;&#10;**When not to use:**  &#10;&#10;- When subsystem is already simple.&#10;&#10;---&#10;&#10;### Flyweight&#10;&#10;Reduces memory usage by sharing data.&#10;&#10;**Example (Java):**&#10;```java&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class Flyweight {&#10;    private String shared;&#10;    public Flyweight(String shared) { this.shared = shared; }&#10;}&#10;&#10;public class FlyweightFactory {&#10;    private Map&lt;String, Flyweight&gt; flyweights = new HashMap&lt;&gt;();&#10;    public Flyweight getFlyweight(String shared) {&#10;        if (!flyweights.containsKey(shared)) {&#10;            flyweights.put(shared, new Flyweight(shared));&#10;        }&#10;        return flyweights.get(shared);&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When many objects share common data.&#10;&#10;**When not to use:**  &#10;&#10;- When objects are unique.&#10;&#10;---&#10;&#10;### Proxy&#10;&#10;Provides a surrogate for another object.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Subject {&#10;    void request();&#10;}&#10;&#10;public class RealSubject implements Subject {&#10;    public void request() { System.out.println(&quot;RealSubject&quot;); }&#10;}&#10;&#10;public class Proxy implements Subject {&#10;    private RealSubject real;&#10;    public Proxy(RealSubject real) { this.real = real; }&#10;    public void request() {&#10;        System.out.println(&quot;Proxy: Checking access&quot;);&#10;        real.request();&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For access control, lazy loading, logging.&#10;&#10;**When not to use:**  &#10;&#10;- When direct access is acceptable.&#10;&#10;---&#10;&#10;## Behavioral Patterns&#10;&#10;### Chain of Responsibility&#10;&#10;Passes a request along a chain of handlers.&#10;&#10;**Example (Java):**&#10;```java&#10;public abstract class Handler {&#10;    protected Handler next;&#10;    public void setNext(Handler next) { this.next = next; }&#10;    public void handle(String request) {&#10;        if (next != null) next.handle(request);&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When multiple objects can handle a request.&#10;&#10;**When not to use:**  &#10;&#10;- When only one handler is needed.&#10;&#10;---&#10;&#10;### Command&#10;&#10;Encapsulates a request as an object.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Command {&#10;    void execute();&#10;}&#10;&#10;public class LightOnCommand implements Command {&#10;    public void execute() { System.out.println(&quot;Light On&quot;); }&#10;}&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class Remote {&#10;    private List&lt;Command&gt; commands = new ArrayList&lt;&gt;();&#10;    public void addCommand(Command cmd) { commands.add(cmd); }&#10;    public void run() {&#10;        for (Command cmd : commands) { cmd.execute(); }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For undo/redo, queuing, logging.&#10;&#10;**When not to use:**  &#10;&#10;- When simple method calls suffice.&#10;&#10;---&#10;&#10;### Interpreter&#10;&#10;Defines a grammar and provides an interpreter.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Expression {&#10;    int interpret();&#10;}&#10;&#10;public class Number implements Expression {&#10;    private int value;&#10;    public Number(int value) { this.value = value; }&#10;    public int interpret() { return value; }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For languages, expressions, parsing.&#10;&#10;**When not to use:**  &#10;&#10;- For simple or infrequent grammar.&#10;&#10;---&#10;&#10;### Iterator&#10;&#10;Provides a way to access elements sequentially.&#10;&#10;**Example (Java):**&#10;```java&#10;import java.util.Iterator;&#10;import java.util.List;&#10;&#10;public class MyIterator implements Iterator&lt;String&gt; {&#10;    private List&lt;String&gt; collection;&#10;    private int index = 0;&#10;    public MyIterator(List&lt;String&gt; collection) { this.collection = collection; }&#10;    public boolean hasNext() { return index &lt; collection.size(); }&#10;    public String next() { return collection.get(index++); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to traverse a collection.&#10;&#10;**When not to use:**  &#10;&#10;- When direct access is sufficient.&#10;&#10;---&#10;&#10;### Mediator&#10;&#10;Encapsulates how objects interact.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Mediator {&#10;    void notify(Component sender, String event);&#10;}&#10;&#10;public class Component {&#10;    private Mediator mediator;&#10;    public Component(Mediator mediator) { this.mediator = mediator; }&#10;    public void doSomething() { mediator.notify(this, &quot;event&quot;); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When objects communicate in complex ways.&#10;&#10;**When not to use:**  &#10;&#10;- When communication is simple.&#10;&#10;---&#10;&#10;### Memento&#10;&#10;Captures and restores an object's state.&#10;&#10;**Example (Java):**&#10;```java&#10;public class Memento {&#10;    private String state;&#10;    public Memento(String state) { this.state = state; }&#10;    public String getState() { return state; }&#10;}&#10;&#10;public class Originator {&#10;    private String state;&#10;    public void setState(String state) { this.state = state; }&#10;    public Memento save() { return new Memento(state); }&#10;    public void restore(Memento memento) { state = memento.getState(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For undo/redo functionality.&#10;&#10;**When not to use:**  &#10;&#10;- When state is simple or not needed.&#10;&#10;---&#10;&#10;### Observer&#10;&#10;One-to-many dependency so dependents are notified of changes.&#10;&#10;**Example (Java):**&#10;```java&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public interface Observer {&#10;    void update();&#10;}&#10;&#10;public class Subject {&#10;    private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();&#10;    public void attach(Observer obs) { observers.add(obs); }&#10;    public void notifyObservers() {&#10;        for (Observer obs : observers) { obs.update(); }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- For event handling, UI updates.&#10;&#10;**When not to use:**  &#10;&#10;- When only one object needs notification.&#10;&#10;---&#10;&#10;### State&#10;&#10;Alters behavior when internal state changes.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface State {&#10;    void handle();&#10;}&#10;&#10;public class Context {&#10;    private State state;&#10;    public Context(State state) { this.state = state; }&#10;    public void request() { state.handle(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When object behavior depends on state.&#10;&#10;**When not to use:**  &#10;&#10;- When state changes are rare.&#10;&#10;---&#10;&#10;### Strategy&#10;&#10;Encapsulates interchangeable algorithms.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Strategy {&#10;    int execute(int[] data);&#10;}&#10;&#10;public class SortStrategy implements Strategy {&#10;    public int execute(int[] data) {&#10;        java.util.Arrays.sort(data);&#10;        return data[0]; // Just for demonstration&#10;    }&#10;}&#10;&#10;public class Context {&#10;    private Strategy strategy;&#10;    public Context(Strategy strategy) { this.strategy = strategy; }&#10;    public int doTask(int[] data) { return strategy.execute(data); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When multiple algorithms are needed.&#10;&#10;**When not to use:**  &#10;&#10;- When only one algorithm is used.&#10;&#10;---&#10;&#10;### Template Method&#10;&#10;Defines the skeleton of an algorithm, deferring steps to subclasses.&#10;&#10;**Example (Java):**&#10;```java&#10;public abstract class AbstractClass {&#10;    public final void templateMethod() {&#10;        step1();&#10;        step2();&#10;    }&#10;    protected abstract void step1();&#10;    protected abstract void step2();&#10;}&#10;&#10;public class ConcreteClass extends AbstractClass {&#10;    protected void step1() { System.out.println(&quot;Step 1&quot;); }&#10;    protected void step2() { System.out.println(&quot;Step 2&quot;); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When algorithms have invariant steps.&#10;&#10;**When not to use:**  &#10;&#10;- When steps never change.&#10;&#10;---&#10;&#10;### Visitor&#10;&#10;Represents an operation to be performed on elements of an object structure.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Visitor {&#10;    void visit(Element element);&#10;}&#10;&#10;public interface Element {&#10;    void accept(Visitor visitor);&#10;}&#10;&#10;public class ConcreteElement implements Element {&#10;    public void accept(Visitor visitor) { visitor.visit(this); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;&#10;- When you need to perform operations on object structures.&#10;&#10;**When not to use:**  &#10;&#10;- When object structure rarely changes.&#10;&#10;---&#10;&#10;## Summary&#10;&#10;The 23 core design patterns (Gang of Four) are essential tools for software engineers.  &#10;They provide proven solutions to common problems in software design, improve code maintainability, and are frequently discussed in interviews.  &#10;Understanding these patterns helps you write flexible, scalable, and robust code." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/content/posts/system_design/jee_design_patterns.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/content/posts/system_design/jee_design_patterns.md" />
              <option name="originalContent" value="+++&#10;date = '2024-05-03T12:44:47+10:00'&#10;draft = false&#10;title = 'JEE Design Patterns'&#10;tags = ['JEE Design Patterns', 'Interview']&#10;+++&#10;&#10;About JEE Design Patterns.&#10;&#10;## Table of Contents&#10;" />
              <option name="updatedContent" value="+++&#10;date = '2025-05-03T12:44:47+10:00'&#10;draft = false&#10;title = 'JEE Design Patterns'&#10;tags = ['JEE Design Patterns', 'Interview']&#10;+++&#10;&#10;JEE design patterns are specialized solutions for enterprise Java applications. They address scalability, maintainability, and performance challenges in distributed systems, helping developers build robust, modular, and efficient enterprise-grade software.&#10;&#10;## Table of Contents&#10;&#10;- [Presentation Tier Patterns](#presentation-tier-patterns)&#10;  - [Intercepting Filter](#intercepting-filter)&#10;  - [Front Controller](#front-controller)&#10;  - [View Helper](#view-helper)&#10;  - [Composite View](#composite-view)&#10;- [Business Tier Patterns](#business-tier-patterns)&#10;  - [Business Delegate](#business-delegate)&#10;  - [Session Facade](#session-facade)&#10;  - [Application Service](#application-service)&#10;  - [Service Locator](#service-locator)&#10;  - [Transfer Object](#transfer-object)&#10;- [Integration Tier Patterns](#integration-tier-patterns)&#10;  - [Data Access Object (DAO)](#data-access-object-dao)&#10;  - [Service Activator](#service-activator)&#10;  - [Web Service Broker](#web-service-broker)&#10;- [Summary](#summary)&#10;&#10;---&#10;&#10;## Presentation Tier Patterns&#10;&#10;### Intercepting Filter&#10;&#10;Provides centralized request pre-processing and post-processing.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface Filter {&#10;    void execute(String request);&#10;}&#10;&#10;public class AuthenticationFilter implements Filter {&#10;    public void execute(String request) {&#10;        System.out.println(&quot;Authenticating request: &quot; + request);&#10;    }&#10;}&#10;&#10;public class FilterChain {&#10;    private List&lt;Filter&gt; filters = new ArrayList&lt;&gt;();&#10;    public void addFilter(Filter filter) { filters.add(filter); }&#10;    public void execute(String request) {&#10;        for (Filter filter : filters) { filter.execute(request); }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- When you need reusable request processing logic (logging, authentication).&#10;&#10;**When not to use:**  &#10;- When processing logic is simple or not reusable.&#10;&#10;---&#10;&#10;### Front Controller&#10;&#10;Centralizes request handling to improve control and flexibility.&#10;&#10;**Example (Java):**&#10;```java&#10;public class FrontController {&#10;    public void dispatchRequest(String request) {&#10;        if (&quot;HOME&quot;.equals(request)) {&#10;            System.out.println(&quot;Displaying Home Page&quot;);&#10;        } else {&#10;            System.out.println(&quot;404 Not Found&quot;);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- When you want a single entry point for requests.&#10;&#10;**When not to use:**  &#10;- For very simple applications.&#10;&#10;---&#10;&#10;### View Helper&#10;&#10;Separates business logic from view rendering.&#10;&#10;**Example (Java):**&#10;```java&#10;public class ViewHelper {&#10;    public String formatDate(Date date) {&#10;        return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(date);&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- When you want to keep views clean and reusable.&#10;&#10;**When not to use:**  &#10;- When formatting logic is trivial.&#10;&#10;---&#10;&#10;### Composite View&#10;&#10;Creates views from modular, reusable subviews.&#10;&#10;**Example (Java):**&#10;```java&#10;public interface View {&#10;    void render();&#10;}&#10;&#10;public class HeaderView implements View {&#10;    public void render() { System.out.println(&quot;Header&quot;); }&#10;}&#10;&#10;public class CompositeView implements View {&#10;    private List&lt;View&gt; views = new ArrayList&lt;&gt;();&#10;    public void addView(View view) { views.add(view); }&#10;    public void render() {&#10;        for (View view : views) { view.render(); }&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- For complex UIs with reusable components.&#10;&#10;**When not to use:**  &#10;- For simple, static views.&#10;&#10;---&#10;&#10;## Business Tier Patterns&#10;&#10;### Business Delegate&#10;&#10;Decouples presentation and business logic.&#10;&#10;**Example (Java):**&#10;```java&#10;public class BusinessService {&#10;    public void doTask() { System.out.println(&quot;Business logic executed&quot;); }&#10;}&#10;&#10;public class BusinessDelegate {&#10;    private BusinessService service = new BusinessService();&#10;    public void executeTask() { service.doTask(); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- When you want to hide business logic complexity from the presentation tier.&#10;&#10;**When not to use:**  &#10;- When business logic is simple.&#10;&#10;---&#10;&#10;### Session Facade&#10;&#10;Provides a unified interface to a set of business services.&#10;&#10;**Example (Java):**&#10;```java&#10;public class OrderService { public void placeOrder() {} }&#10;public class PaymentService { public void processPayment() {} }&#10;&#10;public class SessionFacade {&#10;    private OrderService orderService = new OrderService();&#10;    private PaymentService paymentService = new PaymentService();&#10;    public void completeOrder() {&#10;        orderService.placeOrder();&#10;        paymentService.processPayment();&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- When you want to reduce network calls and simplify client interaction.&#10;&#10;**When not to use:**  &#10;- When only one service is involved.&#10;&#10;---&#10;&#10;### Application Service&#10;&#10;Coordinates business logic across multiple operations.&#10;&#10;**Example (Java):**&#10;```java&#10;public class ApplicationService {&#10;    public void performBusinessOperation() {&#10;        // Business logic spanning multiple domain objects&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- For complex business workflows.&#10;&#10;**When not to use:**  &#10;- For simple, single-step operations.&#10;&#10;---&#10;&#10;### Service Locator&#10;&#10;Centralizes service lookup and management.&#10;&#10;**Example (Java):**&#10;```java&#10;public class ServiceLocator {&#10;    private static Map&lt;String, Object&gt; services = new HashMap&lt;&gt;();&#10;    public static Object getService(String name) { return services.get(name); }&#10;    public static void registerService(String name, Object service) { services.put(name, service); }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- When you need to decouple service consumers from service creation.&#10;&#10;**When not to use:**  &#10;- When dependency injection is preferred.&#10;&#10;---&#10;&#10;### Transfer Object&#10;&#10;Encapsulates data for transfer between layers.&#10;&#10;**Example (Java):**&#10;```java&#10;public class CustomerDTO {&#10;    private String name;&#10;    private String email;&#10;    // getters and setters&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- When transferring multiple data fields between layers.&#10;&#10;**When not to use:**  &#10;- For simple, single-field transfers.&#10;&#10;---&#10;&#10;## Integration Tier Patterns&#10;&#10;### Data Access Object (DAO)&#10;&#10;Abstracts and encapsulates all access to the data source.&#10;&#10;**Example (Java):**&#10;```java&#10;public class CustomerDAO {&#10;    public CustomerDTO findCustomerById(int id) {&#10;        // DB lookup logic&#10;        return new CustomerDTO();&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- When you want to separate persistence logic from business logic.&#10;&#10;**When not to use:**  &#10;- For trivial data access.&#10;&#10;---&#10;&#10;### Service Activator&#10;&#10;Enables asynchronous invocation of business services.&#10;&#10;**Example (Java):**&#10;```java&#10;public class ServiceActivator {&#10;    public void activateService(Runnable serviceTask) {&#10;        new Thread(serviceTask).start();&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- For asynchronous processing.&#10;&#10;**When not to use:**  &#10;- For synchronous, simple calls.&#10;&#10;---&#10;&#10;### Web Service Broker&#10;&#10;Centralizes and manages web service interactions.&#10;&#10;**Example (Java):**&#10;```java&#10;public class WebServiceBroker {&#10;    public void callService(String endpoint) {&#10;        System.out.println(&quot;Calling web service at &quot; + endpoint);&#10;    }&#10;}&#10;```&#10;&#10;**When to use:**  &#10;- For integrating multiple web services.&#10;&#10;**When not to use:**  &#10;- For direct, simple web service calls.&#10;&#10;---&#10;&#10;## Summary&#10;&#10;JEE design patterns help solve common problems in enterprise Java applications.  &#10;They improve scalability, maintainability, and modularity, and are essential knowledge for interviews and building robust distributed systems." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/themes/gravionis/layouts/_partials/header.html">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/themes/gravionis/layouts/_partials/header.html" />
              <option name="originalContent" value="&lt;div style=&quot;position: fixed; top: 0; left: 0; width: 100vw; height: 64px; background: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.03); z-index: 201; display: flex; flex-direction: row; align-items: center; padding: 0 2rem;&quot;&gt;&#10;  &lt;h1 style=&quot;margin: 0 2rem 0 0; font-size: 1.5rem;&quot;&gt;{{ site.Title }}&lt;/h1&gt;&#10;  &lt;nav style=&quot;height: 100%; display: flex; align-items: center; margin-left: auto; margin-right: 8vw;&quot;&gt;&#10;    {{ partial &quot;menu.html&quot; (dict &quot;menuID&quot; &quot;main&quot; &quot;page&quot; .) }}&#10;  &lt;/nav&gt;&#10;&lt;/div&gt;&#10;&lt;!-- Add extra top margin to main content to shift blogs below the header --&gt;&#10;&lt;style&gt;&#10;  body {&#10;    margin-top: 64px; /* Header height */&#10;    margin-left: 5vw; /* Move content further to the right */&#10;    margin-right: 0;&#10;    width: 100%;&#10;    font-size: 0.95rem;&#10;    background: #f0f0f0;&#10;  }&#10;  @media (max-width: 600px) {&#10;    body {&#10;      margin-top: 56px;&#10;      margin-left: 1rem; /* Slightly increased margin on mobile */&#10;      margin-right: 0;&#10;      width: 100%;&#10;      font-size: 1rem;&#10;      background: #f0f0f0;&#10;    }&#10;    .top-menu {&#10;      display: none;&#10;    }&#10;  }&#10;  /* Glow effect for menu items on hover */&#10;  .menu-glow:hover {&#10;    box-shadow: 0 0 8px 2px #0078ff, 0 0 2px 1px #fff;&#10;    background: #f0f8ff;&#10;    color: #0078ff !important;&#10;    transition: box-shadow 0.2s, background 0.2s, color 0.2s;&#10;  }&#10;&lt;/style&gt;&#10;" />
              <option name="updatedContent" value="&lt;div id=&quot;main-header&quot; style=&quot;position: fixed; top: 0; left: 0; width: 100vw; height: 64px; background: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.03); z-index: 201; display: flex; flex-direction: row; align-items: center; padding: 0 2rem;&quot;&gt;&#10;  &lt;h1 style=&quot;margin: 0 2rem 0 0; font-size: 1.5rem;&quot;&gt;{{ site.Title }}&lt;/h1&gt;&#10;  &lt;nav style=&quot;height: 100%; display: flex; align-items: center; margin-left: auto; margin-right: 8vw;&quot;&gt;&#10;    {{ partial &quot;menu.html&quot; (dict &quot;menuID&quot; &quot;main&quot; &quot;page&quot; .) }}&#10;  &lt;/nav&gt;&#10;&lt;/div&gt;&#10;&lt;!-- Add extra top margin to main content to shift blogs below the header --&gt;&#10;&lt;style&gt;&#10;  body {&#10;    margin-top: 64px; /* Header height */&#10;    margin-left: 8vw; /* Move content further to the right */&#10;    margin-right: 0;&#10;    width: 100%;&#10;    font-size: 0.95rem;&#10;    background: #f0f0f0;&#10;  }&#10;  #main-header {&#10;    box-shadow: 0 2px 8px 2px #0078ff, 0 0 8px 2px #fff;&#10;    transition: box-shadow 0.3s;&#10;  }&#10;  #main-header:hover {&#10;    box-shadow: 0 0 24px 6px #0078ff, 0 0 12px 4px #fff;&#10;    transition: box-shadow 0.3s;&#10;  }&#10;  @media (max-width: 600px) {&#10;    body {&#10;      margin-top: 56px;&#10;      margin-left: 1rem; /* Slightly increased margin on mobile */&#10;      margin-right: 0;&#10;      width: 100%;&#10;      font-size: 1rem;&#10;      background: #f0f0f0;&#10;    }&#10;    .top-menu {&#10;      display: none;&#10;    }&#10;  }&#10;  /* Glow effect for menu items on hover */&#10;  .menu-glow:hover {&#10;    box-shadow: 0 0 8px 2px #0078ff, 0 0 2px 1px #fff;&#10;    background: #f0f8ff;&#10;    color: #0078ff !important;&#10;    transition: box-shadow 0.2s, background 0.2s, color 0.2s;&#10;  }&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>